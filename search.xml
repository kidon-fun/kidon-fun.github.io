<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>springboot源码阅读——@SpringBootApplication</title>
      <link href="/2022/03/07/study-in-springboot/"/>
      <url>/2022/03/07/study-in-springboot/</url>
      
        <content type="html"><![CDATA[<html><head><script src="\assets\js\APlayer.min.js"> </script></head><body><p>我们都知道springboot提供给使用者“开箱即用”的体验。相比于spring，springboot提供了更加便捷的功能，比如自动配置、内嵌容器、Actuator监控等。在这里我们主要讨论springboot最显著和最吸引人的特点之一——自动配置。</p><p>一般来说，我们在pom中引入相应的依赖（starter）并在启动类上如下配置即可完成了一个springboot项目。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainApplication</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        SpringApplication.run(MainApplication.class, args);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>在这里我们有两个线索，一个是<code>@SpringBootApplication</code>注解，一个是静态方法<code>SpringApplication.run()</code>。</p><p>我们先从<code>@SpringBootApplication</code>入手，而<code>SpringApplication.run()</code>程序入口我们将在之后的博客介绍。</p><h1 id="SpringBootApplication"><a href="#SpringBootApplication" class="headerlink" title="@SpringBootApplication"></a>@SpringBootApplication</h1><p><code>@SpringBootApplication</code>是一个复合注解，它由<code>@SpringBootCOnfigutation</code>、<code>@EnableAutoConfiguration</code>、<code>@ComponentScan</code>组成，如下。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 省略元注解</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan(excludeFilters = { @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),</span></span><br><span class="line"><span class="meta">@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication {</span><br><span class="line">  <span class="comment">// 省略配置属性</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><code>@SpringBootConfiguration</code>又由<code>@Configuration</code>组成，代表了spring的配置类。</p><p><code>@EnableAutoConfiguration</code>代表了springboot开启了自动配置功能。</p><p><code>@ComponentScan</code>是spring中<em>component</em>的扫描器，可以指定扫描的包和指定过滤器。</p><p>接下来，我们看看<code>@ComponentScan</code>上的<em>excludeFilters</em>上的<code>TypeExcludeFilter</code>和<code>AutoConfigurationExcludeFilter</code>。</p><h2 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="@ComponentScan"></a>@ComponentScan</h2><p><code>@ComponentScan</code>用于扫描指定包目录下的<em>component</em>。其入口是在<code>ConfigurationClassParser</code>中，后文会有介绍。</p><h3 id="1-TypeExcludeFilter"><a href="#1-TypeExcludeFilter" class="headerlink" title="1. TypeExcludeFilter"></a>1. TypeExcludeFilter</h3><p>其实现非常简单，就是查找所有的<code>TypeExcludeFilter</code>类型（包含子类）的bean，并将这些bean用于对候选<em>component</em>的筛选。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> IOException </span>{</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.beanFactory <span class="keyword">instanceof</span> ListableBeanFactory &amp;&amp; getClass() == TypeExcludeFilter.class) {</span><br><span class="line"><span class="keyword">for</span> (TypeExcludeFilter delegate : getDelegates()) {</span><br><span class="line"><span class="keyword">if</span> (delegate.match(metadataReader, metadataReaderFactory)) {</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Collection&lt;TypeExcludeFilter&gt; <span class="title">getDelegates</span><span class="params">()</span> </span>{</span><br><span class="line">Collection&lt;TypeExcludeFilter&gt; delegates = <span class="keyword">this</span>.delegates;</span><br><span class="line"><span class="keyword">if</span> (delegates == <span class="keyword">null</span>) {</span><br><span class="line">delegates = ((ListableBeanFactory) <span class="keyword">this</span>.beanFactory).getBeansOfType(TypeExcludeFilter.class).values();</span><br><span class="line"><span class="keyword">this</span>.delegates = delegates;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> delegates;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h3 id="2-AutoConfigurationExcludeFilter"><a href="#2-AutoConfigurationExcludeFilter" class="headerlink" title="2. AutoConfigurationExcludeFilter"></a>2. AutoConfigurationExcludeFilter</h3><p>这个类的作用是跳过具有<code>@Configuration</code>注解而且是<em>autoConfituration</em>(META-INF/spring.factories中的org.springframework.boot.autoconfigure.EnableAutoConfiguration属性)。这样做的目的是扫描的时候忽略自动配置类，将是否导入配置的判断交由给<code>@EnableAutoConfiguration</code>决定。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> IOException </span>{</span><br><span class="line"><span class="keyword">return</span> isConfiguration(metadataReader) &amp;&amp; isAutoConfiguration(metadataReader);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>接下来就是本文的核心重点<code>@EnableAutoConfiguration</code>了。</p><h2 id="EnableAutoConfiguration"><a href="#EnableAutoConfiguration" class="headerlink" title="@EnableAutoConfiguration"></a>@EnableAutoConfiguration</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 省略其他元注解</span></span><br><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import(AutoConfigurationImportSelector.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration {</span><br><span class="line"></span><br><span class="line">   String ENABLED_OVERRIDE_PROPERTY = <span class="string">"spring.boot.enableautoconfiguration"</span>;</span><br><span class="line"></span><br><span class="line">   Class&lt;?&gt;[] exclude() <span class="keyword">default</span> {};</span><br><span class="line"></span><br><span class="line">   String[] excludeName() <span class="keyword">default</span> {};</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><code>@EnableAutoConfiguration</code>注解由<code>@AutoConfigurationPackage</code>和<code>@Import(AutoConfigurationImportSelector.class)</code>组成。</p><p><code>@AutoConfigurationPackage</code>的作用是，如果<em>basePackages</em>和<code>basePackageClasses</code>没有配置，则使用被注解的类所在的包作为自动配置包。</p><h3 id="AutoConfigurationImportSelector"><a href="#AutoConfigurationImportSelector" class="headerlink" title="AutoConfigurationImportSelector"></a>AutoConfigurationImportSelector</h3><p>该类是的作用是获取并筛选自动配置类，核心方法是<code>getAutoConfigurationEntry()</code>，此外还有三个内部类<code>ConfigurationClassFilter</code>、<code>AutoConfigurationGroup</code>和<code>AutoConfigurationEntry</code>。</p><p>我们可以在<code>getAutoConfigurationEntry()</code>方法处<strong>打一个断点，然后观察一下调用栈</strong>。可以看到其被<code>AutoConfigurationGroup.process()</code>方法调用，而上一层方法是<code>ConfigurationClassParser</code>，再进一步可<code>ConfigurationClassPostProcessor</code>(其实现了接口<code>BeanDefinitionRegistryPostProcessor</code>(<code>BeanFactoryPostProcessor</code>))。</p><h4 id="getAutoConfigurationEntry"><a href="#getAutoConfigurationEntry" class="headerlink" title=".getAutoConfigurationEntry()"></a><code>.getAutoConfigurationEntry()</code></h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> AutoConfigurationEntry <span class="title">getAutoConfigurationEntry</span><span class="params">(AnnotationMetadata annotationMetadata)</span> </span>{</span><br><span class="line">    <span class="comment">// 是否开启自动配置，'spring.boot.enableautoconfiguration'环境变量，缺省值为true</span></span><br><span class="line"><span class="keyword">if</span> (!isEnabled(annotationMetadata)) {</span><br><span class="line"><span class="keyword">return</span> EMPTY_ENTRY;</span><br><span class="line">}</span><br><span class="line">  <span class="comment">// @EnableAutoConfiguration上配置的exclude和excludeName</span></span><br><span class="line">AnnotationAttributes attributes = getAttributes(annotationMetadata);</span><br><span class="line">  <span class="comment">// 获取自动配置的候选者</span></span><br><span class="line">  <span class="comment">// (classpath下META-INF/spring.factories配置的org.springframework.boot.autoconfigure.EnableAutoConfiguration)</span></span><br><span class="line">List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes);</span><br><span class="line"><span class="comment">// 移除重复的配置类</span></span><br><span class="line">  configurations = removeDuplicates(configurations);</span><br><span class="line">  <span class="comment">// 获取需要排除的自动配置类</span></span><br><span class="line">  <span class="comment">// (@EnableAutoConfiguration上配置的exclude和excludeName，以及'spring.autoconfigure.exclude'环境变量)</span></span><br><span class="line">Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes);</span><br><span class="line">  <span class="comment">// 检查那些需要排除，但不是候选者的配置类，如果存在则抛出异常</span></span><br><span class="line">checkExcludedClasses(configurations, exclusions);</span><br><span class="line">  <span class="comment">// 移除exclueded的自动配置类</span></span><br><span class="line">configurations.removeAll(exclusions);</span><br><span class="line">  <span class="comment">// 获取ConfigurationClassFilter，并过滤自动配置类</span></span><br><span class="line">  <span class="comment">// (classpath下META-INF/spring.factories配置的org.springframework.boot.autoconfigure.AutoConfigurationImportFilter)</span></span><br><span class="line">configurations = getConfigurationClassFilter().filter(configurations);</span><br><span class="line">  <span class="comment">// 向AutoConfigurationImportListener发布AutoConfigurationImportEvent事件</span></span><br><span class="line">  <span class="comment">// (classpath下META-INF/spring.factories配置的org.springframework.boot.autoconfigure.AutoConfigurationImportListener)</span></span><br><span class="line">fireAutoConfigurationImportEvents(configurations, exclusions);</span><br><span class="line">  <span class="comment">// 组装并返回AutoConfigurationEntry</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> AutoConfigurationEntry(configurations, exclusions);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>如上，在springboot的自动配置中<strong>META-INF/spring.factories</strong>起了至关重要的作用**(SPI)**，其提供了自动配置类标识、过滤和事件监听的功能接口。</p><p>上面的代码有两处过滤候选的自动配置类，一是根据<code>@EnableAutoConfiguration</code>上配置的<em>exclude</em>和<em>excludeName</em>属性，二是根据<code>ConfigurationClassFilter</code>的<code>fitler()</code>方法，其实内部调用的就是<code>AutoConfigurationImportFilter</code>的<code>macth()</code>方法。查看<code>AutoConfigurationImportFilter</code>实现类中有<code>OnBeanCondition</code>、<code>OnClassCondition</code>和<code>OnWebApplicationCondition</code>这三个类(也是spring.factories中配置的)，而这三个类又都是<code>Condition</code>的子类。</p><p>那<code>AutoConfigurationImportFilter</code>和<code>Condition</code>是什么关系呢？应该说是没什么直接的关系。它们服务与不同的流程，前者是服务于spring.factories的自动配置类的候选者过滤时，而后者作用于判断一个<em>component</em>或者<em>bean</em>是满足被加载到bean容器中的条件。而他们刚好拥有三个相同的子类实现罢了，后面有详细介绍<code>Condition</code>体系的博客。</p><p>接下来我们看<code>ConfigurationClassFilter</code>这个内部类。</p><h4 id="ConfigurationClassFilter"><a href="#ConfigurationClassFilter" class="headerlink" title="ConfigurationClassFilter"></a>ConfigurationClassFilter</h4><p><code>ConfigurationClassFilter</code>是自动配置类过滤器的集合。将其应用在自动配合候选者集合中，筛选掉那些不符合条件的候选自动配置类。</p><p>看下面代码，实际的过滤条件在<code>AutoConfigurationImportFilter</code>子类中实现，也就是<code>OnBeanCondition</code>、<code>OnClassCondition</code>和<code>OnWebApplicationCondition</code>。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造方法</span></span><br><span class="line">ConfigurationClassFilter(ClassLoader classLoader, List&lt;AutoConfigurationImportFilter&gt; filters) {</span><br><span class="line">  <span class="comment">// 加载META-INF/spring-autoconfigure-metadata.properties下的属性，在判断匹配的时候使用的配置元数据</span></span><br><span class="line">  <span class="comment">// 主要是springboot内置的判断自动配置类加载的条件</span></span><br><span class="line"><span class="keyword">this</span>.autoConfigurationMetadata = AutoConfigurationMetadataLoader.loadMetadata(classLoader);</span><br><span class="line">  <span class="comment">// AutoConfigurationImportFilter集合</span></span><br><span class="line"><span class="keyword">this</span>.filters = filters;</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 过滤方法，入参为候选的自动配置类</span></span><br><span class="line"><span class="function">List&lt;String&gt; <span class="title">filter</span><span class="params">(List&lt;String&gt; configurations)</span> </span>{</span><br><span class="line"><span class="keyword">long</span> startTime = System.nanoTime();</span><br><span class="line">  <span class="comment">// 拷贝候选者至String数组</span></span><br><span class="line">String[] candidates = StringUtils.toStringArray(configurations);</span><br><span class="line"><span class="keyword">boolean</span> skipped = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">for</span> (AutoConfigurationImportFilter filter : <span class="keyword">this</span>.filters) {</span><br><span class="line">        <span class="comment">// 对候选者数组，调用AutoConfigurationImportFilter的match方法</span></span><br><span class="line"><span class="keyword">boolean</span>[] match = filter.match(candidates, <span class="keyword">this</span>.autoConfigurationMetadata);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; match.length; i++) {</span><br><span class="line"><span class="keyword">if</span> (!match[i]) {</span><br><span class="line">            <span class="comment">// 对于未通过某个过滤器的候选者，将其从候选者数组中移除</span></span><br><span class="line">candidates[i] = <span class="keyword">null</span>;</span><br><span class="line">skipped = <span class="keyword">true</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> (!skipped) {</span><br><span class="line">        <span class="comment">// 如果全部后选择都满足条件，返回原候选者List</span></span><br><span class="line"><span class="keyword">return</span> configurations;</span><br><span class="line">}</span><br><span class="line">List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;(candidates.length);</span><br><span class="line"><span class="keyword">for</span> (String candidate : candidates) {</span><br><span class="line"><span class="keyword">if</span> (candidate != <span class="keyword">null</span>) {</span><br><span class="line">          <span class="comment">// 构造筛选后的候选者List</span></span><br><span class="line">result.add(candidate);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) {</span><br><span class="line"><span class="keyword">int</span> numberFiltered = configurations.size() - result.size();</span><br><span class="line">logger.trace(<span class="string">"Filtered "</span> + numberFiltered + <span class="string">" auto configuration class in "</span></span><br><span class="line">+ TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startTime) + <span class="string">" ms"</span>);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>所以，接下来要分析<code>AutoConfigurationImportFilter</code>的实现类。</p><p>我们以<code>OnClassCondition</code>为例，其也是<code>Condition</code>的实现类，这里我们先不介绍<code>Condition</code>体系，只专注于<code>@EnableAutoConfiguration</code>的能力。</p><h3 id="FilteringSpringBootCondition"><a href="#FilteringSpringBootCondition" class="headerlink" title="FilteringSpringBootCondition"></a>FilteringSpringBootCondition</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">FilteringSpringBootCondition</span> <span class="keyword">extends</span> <span class="title">SpringBootCondition</span></span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">AutoConfigurationImportFilter</span>, <span class="title">BeanFactoryAware</span>, <span class="title">BeanClassLoaderAware</span></span></span><br></pre></td></tr></tbody></table></figure></div><p><code>FilteringSpringBootCondition</code>实现了<code>AutoConfigurationImportFilter</code>定义的<code>match(String[], AutoConfigurationMetadata)</code>方法。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">boolean</span>[] match(String[] autoConfigurationClasses, AutoConfigurationMetadata autoConfigurationMetadata) {</span><br><span class="line"><span class="comment">// 打印条件匹配评估报告</span></span><br><span class="line">  ConditionEvaluationReport report = ConditionEvaluationReport.find(<span class="keyword">this</span>.beanFactory);</span><br><span class="line">  <span class="comment">// 抽象的模板方法，子类实现，用于获取对所有候选自动配置类的匹配结果</span></span><br><span class="line">ConditionOutcome[] outcomes = getOutcomes(autoConfigurationClasses, autoConfigurationMetadata);</span><br><span class="line"><span class="keyword">boolean</span>[] match = <span class="keyword">new</span> <span class="keyword">boolean</span>[outcomes.length];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; outcomes.length; i++) {</span><br><span class="line">      <span class="comment">// 如果outcome为null或者为显示匹配成功时，则表示候选者通过</span></span><br><span class="line">match[i] = (outcomes[i] == <span class="keyword">null</span> || outcomes[i].isMatch());</span><br><span class="line"><span class="keyword">if</span> (!match[i] &amp;&amp; outcomes[i] != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="comment">// outcome显示为不匹配时，记录评估报告</span></span><br><span class="line">logOutcome(autoConfigurationClasses[i], outcomes[i]);</span><br><span class="line"><span class="keyword">if</span> (report != <span class="keyword">null</span>) {</span><br><span class="line">report.recordConditionEvaluation(autoConfigurationClasses[i], <span class="keyword">this</span>, outcomes[i]);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> match;<span class="comment">// 返回匹配结果</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>如上所见<code>FilteringSpringBootCondition</code>也只是做了一些获取匹配结果、打印评估报告等辅助工作，真正的匹配规则还是在子类实现。这里使用了模板方法的设计模式。接下来看看<code>OnClassCondition</code>。</p><h3 id="OnClassCondition"><a href="#OnClassCondition" class="headerlink" title="OnClassCondition"></a>OnClassCondition</h3><p><code>OnClassCondition</code>用于判断类路径下class是否存在。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现父类的抽象方法</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> ConditionOutcome[] getOutcomes(String[] autoConfigurationClasses,</span><br><span class="line">AutoConfigurationMetadata autoConfigurationMetadata) {</span><br><span class="line"><span class="comment">// 这里判断候选者是否匹配有两个方法，一个是多线程版本，一个是单线程版本。一般来说都会走多线程的逻辑，其实现也更加复杂，</span></span><br><span class="line">  <span class="comment">// 而我们只需要了解过滤候选自动配置类的判断逻辑即可，为避免复杂化使用单线程的通路</span></span><br><span class="line"><span class="keyword">if</span> (autoConfigurationClasses.length &gt; <span class="number">1</span> &amp;&amp; Runtime.getRuntime().availableProcessors() &gt; <span class="number">1</span>) {</span><br><span class="line"><span class="keyword">return</span> resolveOutcomesThreaded(autoConfigurationClasses, autoConfigurationMetadata);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> {</span><br><span class="line">OutcomesResolver outcomesResolver = <span class="keyword">new</span> StandardOutcomesResolver(autoConfigurationClasses, <span class="number">0</span>,</span><br><span class="line">autoConfigurationClasses.length, autoConfigurationMetadata, getBeanClassLoader());</span><br><span class="line"><span class="keyword">return</span> outcomesResolver.resolveOutcomes();</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h4 id="StandardOutcomesResolver"><a href="#StandardOutcomesResolver" class="headerlink" title="StandardOutcomesResolver"></a>StandardOutcomesResolver</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">StandardOutcomesResolver</span><span class="params">(String[] autoConfigurationClasses, <span class="keyword">int</span> start, <span class="keyword">int</span> end,</span></span></span><br><span class="line"><span class="params"><span class="function">AutoConfigurationMetadata autoConfigurationMetadata, ClassLoader beanClassLoader)</span> </span>{</span><br><span class="line"><span class="keyword">this</span>.autoConfigurationClasses = autoConfigurationClasses;</span><br><span class="line"><span class="keyword">this</span>.start = start;</span><br><span class="line"><span class="keyword">this</span>.end = end;</span><br><span class="line"><span class="keyword">this</span>.autoConfigurationMetadata = autoConfigurationMetadata;</span><br><span class="line"><span class="keyword">this</span>.beanClassLoader = beanClassLoader;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取结果(委托给getOutcomes())</span></span><br><span class="line"><span class="keyword">public</span> ConditionOutcome[] resolveOutcomes() {</span><br><span class="line"><span class="keyword">return</span> getOutcomes(<span class="keyword">this</span>.autoConfigurationClasses, <span class="keyword">this</span>.start, <span class="keyword">this</span>.end, <span class="keyword">this</span>.autoConfigurationMetadata);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取所有候选者的匹配结果</span></span><br><span class="line"><span class="keyword">private</span> ConditionOutcome[] getOutcomes(String[] autoConfigurationClasses, <span class="keyword">int</span> start, <span class="keyword">int</span> end,</span><br><span class="line">AutoConfigurationMetadata autoConfigurationMetadata) {</span><br><span class="line">ConditionOutcome[] outcomes = <span class="keyword">new</span> ConditionOutcome[end - start];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; end; i++) {</span><br><span class="line">        <span class="comment">// 对候选者遍历</span></span><br><span class="line">String autoConfigurationClass = autoConfigurationClasses[i];</span><br><span class="line"><span class="keyword">if</span> (autoConfigurationClass != <span class="keyword">null</span>) {</span><br><span class="line">          <span class="comment">// 这里有意思的是只对autoConfigurationMetadata中包含有的'ConditionalOnClass'会产出结果，</span></span><br><span class="line">          <span class="comment">// 即META-INF/spring-autoconfigure-metadata.properties中含有的'className+".ConditionalOnClass"'才会</span></span><br><span class="line">          <span class="comment">// 有结果，其他的默认是null(null也表示成功)</span></span><br><span class="line">String candidates = autoConfigurationMetadata.get(autoConfigurationClass, <span class="string">"ConditionalOnClass"</span>);</span><br><span class="line"><span class="keyword">if</span> (candidates != <span class="keyword">null</span>) {</span><br><span class="line">            <span class="comment">// 进一步调用getOutcome，获取单个候选者的结果</span></span><br><span class="line">outcomes[i - start] = getOutcome(candidates);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> outcomes;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取对单个候选者的结果</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> ConditionOutcome <span class="title">getOutcome</span><span class="params">(String candidates)</span> </span>{</span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line"><span class="keyword">if</span> (!candidates.contains(<span class="string">","</span>)) {</span><br><span class="line">          <span class="comment">// 单个</span></span><br><span class="line"><span class="keyword">return</span> getOutcome(candidates, <span class="keyword">this</span>.beanClassLoader);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span> (String candidate : StringUtils.commaDelimitedListToStringArray(candidates)) {</span><br><span class="line">ConditionOutcome outcome = getOutcome(candidate, <span class="keyword">this</span>.beanClassLoader);</span><br><span class="line">          <span class="comment">// 多个，只要有一个有结果立刻返回</span></span><br><span class="line"><span class="keyword">if</span> (outcome != <span class="keyword">null</span>) {</span><br><span class="line"><span class="keyword">return</span> outcome;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">catch</span> (Exception ex) {</span><br><span class="line"><span class="comment">// We'll get another chance later</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取匹配结果，只有不匹配的时候返回ConditionOutcome对象，为null表示匹配成功</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> ConditionOutcome <span class="title">getOutcome</span><span class="params">(String className, ClassLoader classLoader)</span> </span>{</span><br><span class="line">  <span class="comment">// ClassNameFilter.MISSING.matches使用类加载器加载对应的className，如果抛出异常表示类不存在，返回true</span></span><br><span class="line"><span class="keyword">if</span> (ClassNameFilter.MISSING.matches(className, classLoader)) {</span><br><span class="line"><span class="keyword">return</span> ConditionOutcome.noMatch(ConditionMessage.forCondition(ConditionalOnClass.class)</span><br><span class="line">.didNotFind(<span class="string">"required class"</span>).items(Style.QUOTE, className));</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>获取匹配结果经过了层层嵌套，最后其实就是使用<code>Class.forName()</code>方法判断类路径上是否存在指定的类。需要注意的是，这里的<code>OnClassCondition</code>条件只对<code>META-INF/spring-autoconfigure-metadata.properties</code>配置有的类起作用，其他的候选者默认都为匹配。这里也只是使用了<code>AutoConfigurationMetadata</code>里的信息过滤，那么我们常用的<code>@Conditional</code>这些条件注解又是在什么地方起作用的呢？这里存个疑问。</p><p>接下来就是要弄清楚自动配置类导入的调用链路。</p><h3 id="AutoConfigurationGroup"><a href="#AutoConfigurationGroup" class="headerlink" title="AutoConfigurationGroup"></a>AutoConfigurationGroup</h3><p>前面有说道，根据调用堆栈，<code>AutoConfigurationImportSelector.getAutoConfigurationEntry()</code>是在<code>AutoConfigurationGroup</code>中调用的。而<code>AutoCondifurationGroup</code>本身实现也很简单，这里就不贴代码了，简单描述一下。<code>process()</code>能够处理多个<code>DeferredImportSelector</code>并储存为<code>AutoConfigurationEntrys</code>。<code>selectImports()</code>对<code>AutoConfigurationEntrys</code>平铺、过滤、排序和转格式。</p><h3 id="ConfigurationClassParser"><a href="#ConfigurationClassParser" class="headerlink" title="ConfigurationClassParser"></a>ConfigurationClassParser</h3><p>进一步，可以来到<code>ConfigurationClassParse</code>和<code>ConfigurationClassPostProcessor</code>了。</p></body></html>]]></content>
      
      
      
        <tags>
            
            <tag> spring springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring源码学习—— ApplicationContext</title>
      <link href="/2021/10/05/spring-ApplicationContext/"/>
      <url>/2021/10/05/spring-ApplicationContext/</url>
      
        <content type="html"><![CDATA[<html><head><script src="\assets\js\APlayer.min.js"> </script></head><body><p>![image-20211005154324577](/Users/mac/Library/Application Support/typora-user-images/image-20211005154324577.png)</p><h2 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a>ApplicationContext</h2><blockquote><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApplicationContext</span> <span class="keyword">extends</span> <span class="title">EnvironmentCapable</span>, <span class="title">ListableBeanFactory</span>, <span class="title">HierarchicalBeanFactory</span>,</span></span><br><span class="line"><span class="class">      <span class="title">MessageSource</span>, <span class="title">ApplicationEventPublisher</span>, <span class="title">ResourcePatternResolver</span></span></span><br></pre></td></tr></tbody></table></figure></div></blockquote><p><em>context</em>上下文体系是spring在<code>BeanFactory</code>上的进一步扩展，增添了许多能力，比如环境变量、国际化、生命周期、Spring应用事件以及bean工厂的后置处理等。</p><p>而一个<code>ApplicationContext</code>的实现类应该至少具备以下能力：</p><ul><li>BeanFacory中访问Bean的方法（其继承了<code>ListableBeanFactory</code>）</li><li>以一种通用风格的形式加载文件资源的能力（其继承了<code>ResourceLoader</code>）</li><li>发布事件给已注册<em>listeners</em>的能力（其继承了<code>ApplicationEventPublisher</code>）</li><li>处理文本信息、支持国际化的能力（其继承了<code>MessageSource</code>）</li><li>继承父context的能力，后代优先级更高</li></ul><p>此外，还有标准的<code>BeanFactory</code>生命周期能力、检测并调用<code>ApplicationContextAware</code>、<code>ResourceLoaderAware</code>、<code>ApplicationEventPublisherAware</code>、<code>MessageSourceAware</code>等bean</p><p><code>BeanFactory</code>体系这里就不多描述了，主要介绍下其他的接口能力。</p><h3 id="EnvironmentCapable"><a href="#EnvironmentCapable" class="headerlink" title="EnvironmentCapable"></a>EnvironmentCapable</h3><p>此接口从命名上来看就是用来获取<code>Environment</code>变量的。这里我们主要介绍Spring中的环境变量体系。</p><p>从实现方法上看，我们发现Spring中默认使用的是<code>StandardEnvironment</code>对象。</p><h4 id="StandardEnvironment"><a href="#StandardEnvironment" class="headerlink" title="StandardEnvironment"></a>StandardEnvironment</h4><p>![image-20211005155220380](/Users/mac/Library/Application Support/typora-user-images/image-20211005155220380.png)</p><ul><li><p><code>PropertyResolver</code> </p><p>定义了获取属性的方法以及如何解析<code>${...}</code></p></li><li><p><code>ConfigurablePropertyResolver</code></p><p>在<code>PropertyResolver</code> 的基础上增添了配置能力，比如一些前后缀、分隔符、是否忽略无法嵌套解析的错误、设置必须具备的<em>properties</em>和验证<em>properties</em>。此外，还加入<code>ConfigurableConversionService</code>用以类型转换。</p></li><li><p><code>Environment</code> </p><p>spring中环境变量的抽象，环境有两类，分别是<strong>profiles</strong>和<strong>properties</strong>。</p><ul><li>只有给定<em>profile</em>是激活的，关联的BeanDefinition才会被注册</li><li>properties有多种来源：properties文件、jvm系统变量、系统环境变量、JNDI等等，而不同的来源优先级也是有所差异</li></ul></li><li><p><code>ConfigurableEnvironment</code></p><p>此接口主要新增了操作属性源(<code>MutablePropertySources</code>)的能力，还有设置、添加<em>profile</em>，获取系统属性和系统环境变量，合并其他<code>ConfigurableEnvironment</code>。</p></li><li><p><code>MutablePropertySources</code></p><p><code>AbstractEnvironment</code>默认使用的属性源管理类，其内部用<code>List</code>来管理<code>PropertySource</code>(属性源的抽象)，具有优先级关系，<strong>列表前头的优先级高</strong>。</p></li><li><p><code>AbstractEnvironment</code></p><p>其构造方法中使用了<strong>模板方法</strong>供子类自定义属性源。其还提供了实现接口的方法实现，比如属性字符串解析、获取系统属性和系统环境变量等。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> MutablePropertySources propertySources = <span class="keyword">new</span> MutablePropertySources();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AbstractEnvironment</span><span class="params">()</span> </span>{customizePropertySources(<span class="keyword">this</span>.propertySources);}</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">customizePropertySources</span><span class="params">(MutablePropertySources propertySources)</span> </span>{}</span><br></pre></td></tr></tbody></table></figure></div></li><li><p><code>StandardEnvironment</code></p><p>Spring中默认的环境变量对象，主要就是使用系统属性和系统环境变量。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">customizePropertySources</span><span class="params">(MutablePropertySources propertySources)</span> </span>{</span><br><span class="line">    propertySources.addLast(</span><br><span class="line">        <span class="keyword">new</span> PropertiesPropertySource(SYSTEM_PROPERTIES_PROPERTY_SOURCE_NAME, getSystemProperties()));</span><br><span class="line">    propertySources.addLast(</span><br><span class="line">        <span class="keyword">new</span> SystemEnvironmentPropertySource(SYSTEM_ENVIRONMENT_PROPERTY_SOURCE_NAME, getSystemEnvironment()));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></li></ul><h3 id="ApplicationEventPublisher"><a href="#ApplicationEventPublisher" class="headerlink" title="ApplicationEventPublisher"></a>ApplicationEventPublisher</h3><p><code>ApplicationEvent</code>的发布器。用于发布<code>ApplicationEvent</code>，如果事件不是<code>ApplicationEvent</code>会被包装成<code>PayloadApplicationEvent</code>，**其发布动作委托给了<code>ApplicationEventMulticaster</code>**。</p><p>Spring中的事件发布—监听模型主要涉及到三个基础对象：<code>ApplicationEvent</code>、<code>ApplicationListener</code>以及<code>ApplicationEventMulticaster</code>。</p><h4 id="ApplicationEvent"><a href="#ApplicationEvent" class="headerlink" title="ApplicationEvent"></a>ApplicationEvent</h4><blockquote><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationEvent</span> <span class="keyword">extends</span> <span class="title">EventObject</span></span></span><br></pre></td></tr></tbody></table></figure></div></blockquote><p><code>ApplicationEvent</code>中记录了事件源和发生时间。Spring框架生命周期的时间主要有<code>ApplicationContextEvent</code>和<code>SpringApplicationEvent</code>，前者是<code>ApplicationContext</code>的周期事件，而后者是<strong>Springboot</strong>应用的周期事件，这里主要描述的是前者。</p><h5 id="ApplicationContextEvent"><a href="#ApplicationContextEvent" class="headerlink" title="ApplicationContextEvent"></a><code>ApplicationContextEvent</code></h5><ul><li><code>ContextClosedEvent</code> 关闭<code>ApplicationContext</code>时（关闭时会销毁singletons和工厂）</li><li><code>ContextRefreshedEvent</code> 完成<code>ApplicationContext</code>刷新时（每次调用<code>refresh()</code>）</li><li><code>ContextStoppedEvent</code> 停止<code>ApplicationContext</code>时（停止时会调用生命周期处理函数的stop方法）</li><li><code>ContextStartedEvent</code> 启动<code>ApplicationContext</code>完时（调用start方法）</li></ul><h5 id="ApplicationListener"><a href="#ApplicationListener" class="headerlink" title="ApplicationListener"></a><code>ApplicationListener</code></h5><p>泛型接口，不单是Spring应用事件，用户还可以实现对关注的事件类型的监听</p><h5 id="ApplicationEventMulticaster"><a href="#ApplicationEventMulticaster" class="headerlink" title="ApplicationEventMulticaster"></a><code>ApplicationEventMulticaster</code></h5><p>用于管理<em>Listeners</em>并且发布感兴趣的事件给他们。若用户未指定，则其默认使用的实现类是<code>SimpleApplicationEventMulticaster</code>。</p><ul><li><p><code>AbstractApplicationEventMulticaster</code>管理<em>listeneres</em></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用两个Set来存放所有的Listener(和bean name)，用两个的原因是Listener分为单例和非单例的</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ListenerRetriever defaultRetriever = <span class="keyword">new</span> ListenerRetriever(<span class="keyword">false</span>);</span><br><span class="line"><span class="comment">// 缓存，key为eventType(包装成`ResolvableType`)和sourceType的组合，value为符合key的所有Listener</span></span><br><span class="line"><span class="keyword">final</span> Map&lt;ListenerCacheKey, ListenerRetriever&gt; retrieverCache = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">64</span>);</span><br><span class="line"><span class="comment">// 对于Listener的变更需要同步处理</span></span><br><span class="line"><span class="keyword">private</span> Object retrievalMutex = <span class="keyword">this</span>.defaultRetriever;</span><br></pre></td></tr></tbody></table></figure></div></li><li><p><code>SimpleApplicationEventMulticaster</code>发布事件</p> <div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 发布事件给对应的监听者 */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">multicastEvent</span><span class="params">(<span class="keyword">final</span> ApplicationEvent event, <span class="meta">@Nullable</span> ResolvableType eventType)</span> </span>{</span><br><span class="line">    <span class="comment">// 将eventType封装成`ResolvableType`</span></span><br><span class="line">    ResolvableType type = (eventType != <span class="keyword">null</span> ? eventType : resolveDefaultEventType(event));</span><br><span class="line">    Executor executor = getTaskExecutor();</span><br><span class="line">    <span class="comment">// getApplicationListeners方法用于获取和筛选监听该事件的listeners</span></span><br><span class="line">    <span class="keyword">for</span> (ApplicationListener&lt;?&gt; listener : getApplicationListeners(event, type)) {</span><br><span class="line">        <span class="keyword">if</span> (executor != <span class="keyword">null</span>) {</span><br><span class="line">            <span class="comment">// 如果配置了线程池，则用线程池异步执行</span></span><br><span class="line">            executor.execute(() -&gt; invokeListener(listener, event));</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// 未配置线程池，则采用caller run方式执行</span></span><br><span class="line">            invokeListener(listener, event);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></li></ul><h3 id="ResourceLoader"><a href="#ResourceLoader" class="headerlink" title="ResourceLoader"></a>ResourceLoader</h3><p>用于解析符合某些规则的路径字符串，并返回符合规则的对应路径的<code>Resource</code>，实现类比如<code>PathMatchingResourcePatternResolver </code>。</p><h3 id="MessageSource"><a href="#MessageSource" class="headerlink" title="MessageSource"></a>MessageSource</h3><p>国际化相关的类，若服务需要夸语言夸地区等会很有用。由于工作中实际上几乎未使用过，故不叙述。</p><hr><h2 id="AbstractApplicationContext"><a href="#AbstractApplicationContext" class="headerlink" title="AbstractApplicationContext"></a>AbstractApplicationContext</h2><blockquote><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractApplicationContext</span> <span class="keyword">extends</span> <span class="title">DefaultResourceLoader</span></span></span><br><span class="line"><span class="class">      <span class="keyword">implements</span> <span class="title">ConfigurableApplicationContext</span></span></span><br></pre></td></tr></tbody></table></figure></div></blockquote><p><code>AbstractApplicationContext</code>是Context体系下的核心类，核心方法和通用方法都在其中有实现。其未指定配置的储存形式，采用模板方法供子类定制化。</p><p>相比于普通的<em>BeanFactory</em>，<em>ApplicationContext</em>会检测其内部bean factory中定义的特殊bean。因此，本类会自动注册一些<code>BeanFactoryPostProcessors</code>、<code>BeanPostProcessors</code>和<code>ApplicationListeners</code>。</p><p>接下来介绍<code>BeanFactoryPostProcessor</code>和<code>DefaultLifecycleProcessor</code>，其在<code>Context</code>的启动过程或生命周期有着重要的作用</p><h3 id="BeanFactoryPostProcessor"><a href="#BeanFactoryPostProcessor" class="headerlink" title="BeanFactoryPostProcessor"></a>BeanFactoryPostProcessor</h3><p><code>BeanFactory</code>的后置处理器。其在所有的<code>BeanDefinition</code>加载后，任意bean实例化之前调用；它能够调整<code>BeanFacoty</code>的配置项，也能够修改<em>BeanDefinition</em>的属性（这可能将导致bean的提前实例化）；后置处理器的应用有顺序，如果是自动检测，则根据<code>PriorityOrdered</code>和<code>Ordered </code>接口排序（<code>@Order</code>注解无效），如果是编程注册，则按照注册的先后来排序（忽略排序接口）。</p><p>应用方面，比如<code>ConfigurationClassPostProcessor</code>用于解析<code>@Configuration</code>并将<code>BeanDefinition</code>注册到容器中。</p><h3 id="DefaultLifecycleProcessor"><a href="#DefaultLifecycleProcessor" class="headerlink" title="DefaultLifecycleProcessor"></a>DefaultLifecycleProcessor</h3><p><code>DefaultLifecycleProcessor</code>其主要作用是检测出实现了<code>Lifecycle</code>和<code>SmartLifecycle</code>的bean，并在的start和stop中触发对应<code>Lifecycle</code>方法。在<code>SmartLifecycle</code>中，调用的顺序由<em>phase</em>决定（在实现中根据phase分组），<strong>数值越小越先启动，数值越大越先销毁</strong>（<code>Lifecycle</code>默认为0）。</p><p>接下来就叙述<code>Context</code>的启动流程</p><h3 id="AbstractApplicationContext的涉及的Context核心启动流程"><a href="#AbstractApplicationContext的涉及的Context核心启动流程" class="headerlink" title="AbstractApplicationContext的涉及的Context核心启动流程"></a>AbstractApplicationContext的涉及的Context核心启动流程</h3><p>以<code>ClassPathXmlApplicationContext</code>举例，在其构造函数中会调用<code>AbstractApplication.refresh()</code>方法，当然其他的实现类也会调用这个方法。我们就<code>refresh()</code>为切入点，后面还有<code>doClose()</code>等方法的讲述。</p><h4 id="refresh"><a href="#refresh" class="headerlink" title="refresh()"></a><code>refresh()</code></h4><p><code>Context</code>中最核心的逻辑。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>{</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) {<span class="comment">// 整个刷新过程只能有一个线程操作</span></span><br><span class="line">            <span class="comment">// 准备Context的刷新，主要设置一些启动时间、活跃标志以及初始化PropertySouces，</span></span><br><span class="line">            <span class="comment">// 此外，还有early listeners和early evnets的处理</span></span><br><span class="line">            prepareRefresh();</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 获取`ConfigurableListableBeanFactory`，主要的获取或者刷新方法由子类实现</span></span><br><span class="line">            ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 配置上一步获取的`beanFactory`，为实例化bean做准备</span></span><br><span class="line">            prepareBeanFactory(beanFactory);</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="comment">// 空方法，允许子类后置处理'beanFactory'</span></span><br><span class="line">                postProcessBeanFactory(beanFactory);</span><br><span class="line"> </span><br><span class="line">                <span class="comment">// 调用`BeanFactoryPostProcessors`</span></span><br><span class="line">                invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"> </span><br><span class="line">                <span class="comment">// 注册`BeanPostProcessors`</span></span><br><span class="line">                registerBeanPostProcessors(beanFactory);</span><br><span class="line"> </span><br><span class="line">                <span class="comment">// 初始化'messageSource'</span></span><br><span class="line">                initMessageSource();</span><br><span class="line"> </span><br><span class="line">                <span class="comment">// 初始化'applicationEventMulticaster'</span></span><br><span class="line">                initApplicationEventMulticaster();</span><br><span class="line"> </span><br><span class="line">                <span class="comment">// 空方法，允许子类实例化一些特殊的bean</span></span><br><span class="line">                onRefresh();</span><br><span class="line"> </span><br><span class="line">                <span class="comment">// 注册`ApplicationListeners`并且发布'early events'</span></span><br><span class="line">                registerListeners();</span><br><span class="line"> </span><br><span class="line">                <span class="comment">// 实例化所有non-lazy的单例</span></span><br><span class="line">                finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"> </span><br><span class="line">                <span class="comment">// 完成刷新：`LifecycleProcessor.onRefresh`和发布`ContextRefreshedEvent`事件</span></span><br><span class="line">                finishRefresh();</span><br><span class="line">            }</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">catch</span> (BeansException ex) {</span><br><span class="line">                <span class="keyword">if</span> (logger.isWarnEnabled()) {</span><br><span class="line">                    logger.warn(<span class="string">"Exception encountered during context initialization - "</span> +</span><br><span class="line">                            <span class="string">"cancelling refresh attempt: "</span> + ex);</span><br><span class="line">                }</span><br><span class="line"> </span><br><span class="line">                <span class="comment">// 销毁所有的单例，以防止占用资源</span></span><br><span class="line">                destroyBeans();</span><br><span class="line"> </span><br><span class="line">                <span class="comment">// 重置激活状态</span></span><br><span class="line">                cancelRefresh(ex);</span><br><span class="line"> </span><br><span class="line">                <span class="comment">// 向上层抛出异常</span></span><br><span class="line">                <span class="keyword">throw</span> ex;</span><br><span class="line">            }</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">finally</span> {</span><br><span class="line">                <span class="comment">// 重置缓存，因为有些缓存数据在启动后就不再需要了</span></span><br><span class="line">                resetCommonCaches();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure></div><p>下面会一个个地详细分析里面用到的方法。</p><h4 id="prepareRefresh"><a href="#prepareRefresh" class="headerlink" title="prepareRefresh()"></a><code>prepareRefresh()</code></h4><p>准备<em>Context</em>的刷新，主要设置一些启动时间、活跃标志以及初始化<em>PropertySouces</em>等。</p><p>这里还需要注意的是，关于<code>pre-refresh</code>的listeners和<em>early event</em>的处理。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareRefresh</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="comment">// Switch to active.</span></span><br><span class="line">        <span class="keyword">this</span>.startupDate = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">this</span>.closed.set(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">this</span>.active.set(<span class="keyword">true</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) {</span><br><span class="line">            <span class="keyword">if</span> (logger.isTraceEnabled()) {</span><br><span class="line">                logger.trace(<span class="string">"Refreshing "</span> + <span class="keyword">this</span>);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> {</span><br><span class="line">                logger.debug(<span class="string">"Refreshing "</span> + getDisplayName());</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Initialize any placeholder property sources in the context environment.</span></span><br><span class="line">        <span class="comment">// 空方法供子类实现</span></span><br><span class="line">        initPropertySources();</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Validate that all properties marked as required are resolvable:</span></span><br><span class="line">        <span class="comment">// see ConfigurablePropertyResolver#setRequiredProperties</span></span><br><span class="line">        <span class="comment">// 获取环境参数（Environment可能先于此创建），默认是StandardEnvironment</span></span><br><span class="line">        getEnvironment().validateRequiredProperties();</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Store pre-refresh ApplicationListeners...</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.earlyApplicationListeners == <span class="keyword">null</span>) {</span><br><span class="line">            <span class="comment">// 这里会保存pre-refresh状态下的listeners，即使此后再调用刷新，这些listeners会包含在所有的</span></span><br><span class="line">            <span class="comment">// listeners集合中。这么做的目的应该是用户在调用刷新前手动注册了一些liteners，而这些liteners</span></span><br><span class="line">            <span class="comment">// 并不是bean无法自动发现，这里只会设置一次值</span></span><br><span class="line">            <span class="keyword">this</span>.earlyApplicationListeners = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="keyword">this</span>.applicationListeners);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// Reset local application listeners to pre-refresh state.</span></span><br><span class="line">            <span class="keyword">this</span>.applicationListeners.clear();</span><br><span class="line">            <span class="keyword">this</span>.applicationListeners.addAll(<span class="keyword">this</span>.earlyApplicationListeners);</span><br><span class="line">        }</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Allow for the collection of early ApplicationEvents,</span></span><br><span class="line">        <span class="comment">// to be published once the multicaster is available...</span></span><br><span class="line">        <span class="comment">// 同样，在multicaster没有准备好的情况下，先用一个集合来存放需要发布的事件。</span></span><br><span class="line">        <span class="comment">// 在publishEvent方法下，根据这个属性的值来判断multicaster是否已经准备就绪</span></span><br><span class="line">        <span class="keyword">this</span>.earlyApplicationEvents = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure></div><h4 id="obtainFreshBeanFactory"><a href="#obtainFreshBeanFactory" class="headerlink" title="obtainFreshBeanFactory()"></a><code>obtainFreshBeanFactory()</code></h4><p>获取<code>ConfigurableListableBeanFactory</code>，主要的获取或者刷新方法供子类实现。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ConfigurableListableBeanFactory <span class="title">obtainFreshBeanFactory</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="comment">// 抽象方法，子类实现。获取或刷新BeanFactory，待下文会分析`AbstractRefreshableApplicationContext`中的实现</span></span><br><span class="line">        refreshBeanFactory();</span><br><span class="line">        <span class="comment">// 获取上一步得到的`ConfigurableListableBeanFactory`，也是抽象方法，子类实现。</span></span><br><span class="line">        <span class="keyword">return</span> getBeanFactory();</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure></div><h4 id="prepareBeanFactory"><a href="#prepareBeanFactory" class="headerlink" title="prepareBeanFactory()"></a><code>prepareBeanFactory()</code></h4><p>配置上一步获取的<code>BeanFactory</code>，为实例化bean做准备。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>{</span><br><span class="line">        <span class="comment">// 设置与context有关的`ClassLoader`、`ExpressionParser`、`PropertyEditorRegistrar`</span></span><br><span class="line">        beanFactory.setBeanClassLoader(getClassLoader());</span><br><span class="line">        beanFactory.setBeanExpressionResolver(<span class="keyword">new</span> StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));</span><br><span class="line">        beanFactory.addPropertyEditorRegistrar(<span class="keyword">new</span> ResourceEditorRegistrar(<span class="keyword">this</span>, getEnvironment()));</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 这里注册了一个bean的后置处理器`ApplicationContextAwareProcessor`，其作用是为实现</span></span><br><span class="line">        <span class="comment">// `EnvironmentAware`、`EmbeddedValueResolverAware`、`ResourceLoaderAware`、</span></span><br><span class="line">        <span class="comment">// `ApplicationEventPublisherAware`、`MessageSourceAware`和`ApplicationContextAware`接口的</span></span><br><span class="line">        <span class="comment">// bean设置对应属性值，然后将这留个接口加入'ignoredDependencyInterfaces'，用于自动注入中忽略</span></span><br><span class="line">        beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationContextAwareProcessor(<span class="keyword">this</span>));</span><br><span class="line">        beanFactory.ignoreDependencyInterface(EnvironmentAware.class);</span><br><span class="line">        beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);</span><br><span class="line">        beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);</span><br><span class="line">        beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);</span><br><span class="line">        beanFactory.ignoreDependencyInterface(MessageSourceAware.class);</span><br><span class="line">        beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 注册可解决的依赖'resolvableDependencies'，有`BeanFactory`、`ResourceLoader`、`ApplicationEventPublisher`、`ApplicationContext`，这些都不做为bean存在，但是可以装配。</span></span><br><span class="line">        <span class="comment">// 注意，这里注册的`BeanFactory`是正在装备的'beanFactory'，而不是Context(this)</span></span><br><span class="line">        beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);</span><br><span class="line">        beanFactory.registerResolvableDependency(ResourceLoader.class, <span class="keyword">this</span>);</span><br><span class="line">        beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, <span class="keyword">this</span>);</span><br><span class="line">        beanFactory.registerResolvableDependency(ApplicationContext.class, <span class="keyword">this</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 注册bean后置处理器`ApplicationListenerDetector`</span></span><br><span class="line">        <span class="comment">// 其作用是在容器启动时注册listeners，在容器销毁时注销listeners</span></span><br><span class="line">        beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationListenerDetector(<span class="keyword">this</span>));</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 如果包含有'loadTimeWeaver'，则注册`LoadTimeWeaverAwareProcessor`并设置'temporary ClassLoader'</span></span><br><span class="line">        <span class="keyword">if</span> (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {</span><br><span class="line">            beanFactory.addBeanPostProcessor(<span class="keyword">new</span> LoadTimeWeaverAwareProcessor(beanFactory));</span><br><span class="line">            <span class="comment">// Set a temporary ClassLoader for type matching.</span></span><br><span class="line">            beanFactory.setTempClassLoader(<span class="keyword">new</span> ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));</span><br><span class="line">        }</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 注册默认的环境变量beans</span></span><br><span class="line">        <span class="keyword">if</span> (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) {</span><br><span class="line">            beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) {</span><br><span class="line">            beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) {</span><br><span class="line">            beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure></div><h4 id="postProcessBeanFactory"><a href="#postProcessBeanFactory" class="headerlink" title="postProcessBeanFactory()"></a><code>postProcessBeanFactory()</code></h4><p>后置处理<code>BeanFactory</code>，可以看到这个方法是个空方法，是留给子类扩展的一个点。通过覆盖此方法可以修改<code>Context</code>内部的<code>BeanFactory</code>，此时<code>BeanFactory</code>已经初始化并且<strong>所有的<code>BeanDefinition</code>都已经加载</strong>（bean加载的动作是在<code>.obtainFreshBeanFactory()</code>方法中的<code>.refreshBeanFactory()</code>方法完成的，子类实现），<strong>但是还没有bean被实例化</strong>。此方法可用于注册一些特殊的<code>BeanPostProcessors</code>。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>{</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h4 id="invokeBeanFactoryPostProcessors"><a href="#invokeBeanFactoryPostProcessors" class="headerlink" title="invokeBeanFactoryPostProcessors()"></a><code>invokeBeanFactoryPostProcessors()</code></h4><p>见名知意，此方法用于调用已注册的<code>BeanFactoryPostProcessors</code>。</p><p><code>BeanFactoryPostProcessor</code>接口是Spring中很重要的一个扩展点，<em>ApplicationContext</em>将会在<em>bean definitions</em>自动检测<em>BeanFactoryPostProcessor</em>（也可通过<em>ConfigurableApplicationContext</em>编程注册），并且在其他<em>bean</em>创建前调用它们；它能够调整<em>context</em>下<em>bean factory</em>的属性配置，也能够修改<em>BeanDefinition</em>（这可能将导致bean的提前初始化）；可根据<code>PriorityOrdered</code>和<code>Ordered </code>排序（<code>@Order</code>无效），如果是编程注册，则按照注册的先后。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">invokeBeanFactoryPostProcessors</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>{</span><br><span class="line">        <span class="comment">// 委托给'PostProcessorRegistrationDelegate'调用'BeanFactoryPostProcessors'</span></span><br><span class="line">        PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 这里再一次检测BeanFactory是否包含有'loadTimeWeaver'，则进行织入准备。（'loadTimeWeaver'可能通过上面的处理方法注册了，所以需要重新检测一次）</span></span><br><span class="line">        <span class="keyword">if</span> (beanFactory.getTempClassLoader() == <span class="keyword">null</span> &amp;&amp; beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {</span><br><span class="line">            beanFactory.addBeanPostProcessor(<span class="keyword">new</span> LoadTimeWeaverAwareProcessor(beanFactory));</span><br><span class="line">            beanFactory.setTempClassLoader(<span class="keyword">new</span> ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure></div><p>可以看到，主要工作委托给了<code>PostProcessorRegistrationDelegate</code>（这里就不贴代码了，梳理一下主要逻辑）。其中的<code>invokeBeanFactoryPostProcessors</code>方法主要做了这些：</p><ul><li>如果<em>BeanFactory</em>是<code>BeanDefinitionRegistry</code>，则需要<strong>先调用<code>BeanDefinitionRegistryPostProcessors</code></strong><ul><li>首先是<em>ApplicationContext</em>中的（方法参数传入），调用顺序是注册的顺序</li><li>再是<em>BeanFactory</em>中的，调用顺序是先实现了<code>PriorityOrdered</code>的，再是<code>Ordered</code>的，最后是剩余的</li></ul></li><li>接下来调用<code>BeanFactoryPostProcessor</code><ul><li>首先调用上面<code>BeanDefinitionRegistryPostProcessors</code>类型的<code>BeanFactoryPostProcessor</code>，顺序也同上<strong>（如果<em>BeanFactory</em>是<code>BeanDefinitionRegistry</code>，不是的话没有这步）</strong></li><li>接着是<em>ApplicationContext</em>中的（方法参数传入），调用顺序是注册的顺序</li><li>再是<em>BeanFactory</em>中的，调用顺序是先实现了<code>PriorityOrdered</code>的，再是<code>Ordered</code>的，最后是剩余的</li></ul></li><li>清理<em>BeanFactory</em>的元数据缓存</li></ul><h4 id="registerBeanPostProcessors"><a href="#registerBeanPostProcessors" class="headerlink" title="registerBeanPostProcessors()"></a><code>registerBeanPostProcessors()</code></h4><p>调用完<code>BeanFactoryPostProcessors</code>后，接下来是注册<code>BeanPostProcessors</code>。同样，也是委托给类<code>PostProcessorRegistrationDelegate</code>。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerBeanPostProcessors</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>{</span><br><span class="line">PostProcessorRegistrationDelegate.registerBeanPostProcessors(beanFactory, <span class="keyword">this</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>具体过程也就不分析了，总体来说主要有这些逻辑步骤：</p><ul><li><code>BeanPostProcessors</code>的查找依赖于<code>ListableBeanFactory.getBeanNamesForType</code>接口</li><li>注册顺序：<em>PriorityOrdered</em>-&gt;<em>Ordered</em>-&gt;<em>rest</em>（<code>@Order</code>注解无用）</li><li>重新注册<em>internal BeanPostProcessors</em>，即<code>MergedBeanDefinitionPostProcessor</code></li><li>重新注册<code>ApplicationListenerDetector</code>（重新注册会加入到队列末尾）</li></ul><h4 id="initMessageSource"><a href="#initMessageSource" class="headerlink" title="initMessageSource()"></a><code>initMessageSource()</code></h4><p>初始化<code>MessageSource</code>。先查找有没有注册的<code>'messageSource'</code>的bean，若没有默认使用<code>DelegatingMessageSource</code>。</p><h4 id="initApplicationEventMulticaster"><a href="#initApplicationEventMulticaster" class="headerlink" title="initApplicationEventMulticaster()"></a><code>initApplicationEventMulticaster()</code></h4><p>这一步初始化<code>ApplicationEventMulticaster</code>。类似的套路，先查找有没有注册的，若没有则使用默认的<code>SimpleApplicationEventMulticaster</code>（在本文前面介绍<code>ApplicationEventPublisher</code>时有过描述）。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initApplicationEventMulticaster</span><span class="params">()</span> </span>{</span><br><span class="line">        ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line">        <span class="keyword">if</span> (beanFactory.containsLocalBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME)) {</span><br><span class="line">            <span class="keyword">this</span>.applicationEventMulticaster =</span><br><span class="line">                    beanFactory.getBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, ApplicationEventMulticaster.class);</span><br><span class="line">            <span class="keyword">if</span> (logger.isTraceEnabled()) {</span><br><span class="line">                logger.trace(<span class="string">"Using ApplicationEventMulticaster ["</span> + <span class="keyword">this</span>.applicationEventMulticaster + <span class="string">"]"</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// 若没有注册beanName为'applicationEventMulticaster'的bean，则默认使用`SimpleApplicationEventMulticaster`，然后将其注册为单例bean</span></span><br><span class="line">            <span class="keyword">this</span>.applicationEventMulticaster = <span class="keyword">new</span> SimpleApplicationEventMulticaster(beanFactory);</span><br><span class="line">            beanFactory.registerSingleton(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, <span class="keyword">this</span>.applicationEventMulticaster);</span><br><span class="line">            <span class="keyword">if</span> (logger.isTraceEnabled()) {</span><br><span class="line">                logger.trace(<span class="string">"No '"</span> + APPLICATION_EVENT_MULTICASTER_BEAN_NAME + <span class="string">"' bean, using "</span> +</span><br><span class="line">                        <span class="string">"["</span> + <span class="keyword">this</span>.applicationEventMulticaster.getClass().getSimpleName() + <span class="string">"]"</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure></div><h4 id="onRefresh"><a href="#onRefresh" class="headerlink" title="onRefresh()"></a><code>onRefresh()</code></h4><p><code>onRefresh()</code>方法留给子类扩展的点，用于在实例化单例前初始化一些特殊的bean。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onRefresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>{</span><br><span class="line">        <span class="comment">// For subclasses: do nothing by default.</span></span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure></div><h4 id="registerListeners"><a href="#registerListeners" class="headerlink" title="registerListeners()"></a><code>registerListeners()</code></h4><p>前面已经初始化了<code>applicationEventMulticaster</code>，这一步需要往其中注册<code>ApplicationListeners</code>，并且发布<em>early events</em>，清空<em>early events</em>。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerListeners</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="comment">// 首先静态地注册那些特殊的'listeners'</span></span><br><span class="line">        <span class="keyword">for</span> (ApplicationListener&lt;?&gt; listener : getApplicationListeners()) {</span><br><span class="line">            getApplicationEventMulticaster().addApplicationListener(listener);</span><br><span class="line">        }</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 通过bean搜寻'listeners'并注册</span></span><br><span class="line">        <span class="comment">// 注意，这里并没有初始化`FactoryBean`，我们需要让所有常规的beans保持未初始化的状态以应用后置处理器</span></span><br><span class="line">        String[] listenerBeanNames = getBeanNamesForType(ApplicationListener.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">for</span> (String listenerBeanName : listenerBeanNames) {</span><br><span class="line">            getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName);</span><br><span class="line">        }</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 发布'early events'并清空</span></span><br><span class="line">        <span class="comment">// 到这里就和Context的publishEvent中的逻辑对应上了</span></span><br><span class="line">        Set&lt;ApplicationEvent&gt; earlyEventsToProcess = <span class="keyword">this</span>.earlyApplicationEvents;</span><br><span class="line">        <span class="keyword">this</span>.earlyApplicationEvents = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (earlyEventsToProcess != <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">for</span> (ApplicationEvent earlyEvent : earlyEventsToProcess) {</span><br><span class="line">                getApplicationEventMulticaster().multicastEvent(earlyEvent);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure></div><h4 id="finishBeanFactoryInitialization"><a href="#finishBeanFactoryInitialization" class="headerlink" title="finishBeanFactoryInitialization()"></a><code>finishBeanFactoryInitialization()</code></h4><p>到这里，<code>BeanFactory</code>已经准备就绪，接下来需要完成<code>BeanFactory</code>的初始化并且初始化剩余的单例bean(<em>non-lazy-init</em>的bean)。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finishBeanFactoryInitialization</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>{</span><br><span class="line">        <span class="comment">// 为Context初始化‘conversionService’</span></span><br><span class="line">        <span class="keyword">if</span> (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp;</span><br><span class="line">                beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) {</span><br><span class="line">            beanFactory.setConversionService(</span><br><span class="line">                    beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));</span><br><span class="line">        }</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 如果没有，注册一个默认的'embedded value resolver'，主要处理@Value等的占位符。</span></span><br><span class="line">        <span class="comment">// 实现在类PropertyPlaceholderHelper.replacePlaceholders中</span></span><br><span class="line">        <span class="keyword">if</span> (!beanFactory.hasEmbeddedValueResolver()) {</span><br><span class="line">            beanFactory.addEmbeddedValueResolver(strVal -&gt; getEnvironment().resolvePlaceholders(strVal));</span><br><span class="line">        }</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Initialize LoadTimeWeaverAware beans early to allow for registering their transformers early.</span></span><br><span class="line">        String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">for</span> (String weaverAwareName : weaverAwareNames) {</span><br><span class="line">            getBean(weaverAwareName);</span><br><span class="line">        }</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Stop using the temporary ClassLoader for type matching.</span></span><br><span class="line">        <span class="comment">// 停止使用'tempClassLoader'</span></span><br><span class="line">        beanFactory.setTempClassLoader(<span class="keyword">null</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Allow for caching all bean definition metadata, not expecting further changes.</span></span><br><span class="line">        <span class="comment">// 冻结工厂配置</span></span><br><span class="line">        beanFactory.freezeConfiguration();</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 实例化所有的非惰性的单例，其默认实现在'DefaultListableBeanFactory'，在前一篇关于'BeanFactory'的文章有讲述</span></span><br><span class="line">        beanFactory.preInstantiateSingletons();</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure></div><h4 id="finishRefresh"><a href="#finishRefresh" class="headerlink" title="finishRefresh()"></a><code>finishRefresh()</code></h4><p>经过了漫长的分析，这里就是<code>Context</code>刷新的最后一步了，</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finishRefresh</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="comment">// 清理resources缓存 (such as ASM metadata from scanning).</span></span><br><span class="line">        clearResourceCaches();</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 初始化'lifecycleProcessor'，默认是`DefaultLifecycleProcessor`</span></span><br><span class="line">        initLifecycleProcessor();</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 调用`LifecycleProcessor.onRefresh`方法，在上文中有简要叙述</span></span><br><span class="line">        getLifecycleProcessor().onRefresh();</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 发布`ContextRefreshedEvent`事件</span></span><br><span class="line">        publishEvent(<span class="keyword">new</span> ContextRefreshedEvent(<span class="keyword">this</span>));</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 将当前的Context的beans等信息做一个json格式的快照，并注册MBean</span></span><br><span class="line">        LiveBeansView.registerApplicationContext(<span class="keyword">this</span>);</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure></div><p>到这里<code>refresh()</code>的分析就结束了。</p><h4 id="registerShutdownHook"><a href="#registerShutdownHook" class="headerlink" title="registerShutdownHook()"></a><code>registerShutdownHook()</code></h4><p>向<em>jvm</em>注册关闭钩子函数，其作用是使<code>Context</code>能在<em>jvm</em>关闭时实现优雅的关闭。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerShutdownHook</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.shutdownHook == <span class="keyword">null</span>) {</span><br><span class="line">            <span class="comment">// No shutdown hook registered yet.</span></span><br><span class="line">            <span class="keyword">this</span>.shutdownHook = <span class="keyword">new</span> Thread(SHUTDOWN_HOOK_THREAD_NAME) {</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">                    <span class="keyword">synchronized</span> (startupShutdownMonitor) {</span><br><span class="line">                        <span class="comment">// 实际调用doClose方法</span></span><br><span class="line">                        doClose();</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            };</span><br><span class="line">            Runtime.getRuntime().addShutdownHook(<span class="keyword">this</span>.shutdownHook);</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure></div><p>接下来看看<code>doClose()</code>的实现</p><h4 id="doClose"><a href="#doClose" class="headerlink" title="doClose()"></a><code>doClose()</code></h4><p>实际处理<code>Context</code>的关闭工作，或通过<em>shutdownHook</em>调用，或通过手动close调用。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doClose</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="comment">// 检查是否需要关闭</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.active.get() &amp;&amp; <span class="keyword">this</span>.closed.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) {</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) {</span><br><span class="line">                logger.debug(<span class="string">"Closing "</span> + <span class="keyword">this</span>);</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 移除MBean</span></span><br><span class="line">            LiveBeansView.unregisterApplicationContext(<span class="keyword">this</span>);</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="comment">// 发布`ContextClosedEvent`事件</span></span><br><span class="line">                publishEvent(<span class="keyword">new</span> ContextClosedEvent(<span class="keyword">this</span>));</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">catch</span> (Throwable ex) {</span><br><span class="line">                logger.warn(<span class="string">"Exception thrown from ApplicationListener handling ContextClosedEvent"</span>, ex);</span><br><span class="line">            }</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// lifecycleProcessor.onClose，即调用Lifecycle beans的stop方法</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.lifecycleProcessor != <span class="keyword">null</span>) {</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    <span class="keyword">this</span>.lifecycleProcessor.onClose();</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">catch</span> (Throwable ex) {</span><br><span class="line">                    logger.warn(<span class="string">"Exception thrown from LifecycleProcessor on context close"</span>, ex);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 销毁beanFactory的所有缓存的单例</span></span><br><span class="line">            destroyBeans();</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 关闭beanFactory，抽象方法，用于释放内部的beanFactory</span></span><br><span class="line">            closeBeanFactory();</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 空方法，子类扩展</span></span><br><span class="line">            onClose();</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 重置当前`ApplicationListeners`为'pre-refresh'状态</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.earlyApplicationListeners != <span class="keyword">null</span>) {</span><br><span class="line">                <span class="keyword">this</span>.applicationListeners.clear();</span><br><span class="line">                <span class="keyword">this</span>.applicationListeners.addAll(<span class="keyword">this</span>.earlyApplicationListeners);</span><br><span class="line">            }</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 切换状态到非激活态</span></span><br><span class="line">            <span class="keyword">this</span>.active.set(<span class="keyword">false</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure></div><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p><code>AbstractApplicationContext</code>中还有需要子类实现的方法，主要用于<em>internal beanFactory</em>的定制和管理。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException</span>;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">closeBeanFactory</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ConfigurableListableBeanFactory <span class="title">getBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> IllegalStateException</span>;</span><br></pre></td></tr></tbody></table></figure></div><h2 id="AbstractRefreshableApplicationContext"><a href="#AbstractRefreshableApplicationContext" class="headerlink" title="AbstractRefreshableApplicationContext"></a>AbstractRefreshableApplicationContext</h2><p><code>AbstractRefreshableApplicationContext</code>主要是实现了<code>AbstractApplicationContext</code>中定义的抽象方法。可多次调用<code>refresh()</code>方法，每一次内部都创建一个全新的<em>beanFactory</em>，其使用的工厂类是<code>DefaultListableBeanFactory</code>。</p><h3 id="refreshBeanFactory"><a href="#refreshBeanFactory" class="headerlink" title="refreshBeanFactory()"></a><code>refreshBeanFactory()</code></h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>{</span><br><span class="line">        <span class="keyword">if</span> (hasBeanFactory()) {</span><br><span class="line">            <span class="comment">// 若存在'beanFactory'，先销毁单例在关闭工厂</span></span><br><span class="line">            destroyBeans();</span><br><span class="line">            closeBeanFactory();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">// 创建一个新的`DefaultListableBeanFactory`</span></span><br><span class="line">            DefaultListableBeanFactory beanFactory = createBeanFactory();</span><br><span class="line">            beanFactory.setSerializationId(getId());</span><br><span class="line">            <span class="comment">// 自定义工厂，主要是设置'allowBeanDefinitionOverriding'和'allowCircularReferences'</span></span><br><span class="line">            customizeBeanFactory(beanFactory);</span><br><span class="line">            <span class="comment">// 抽象方法，加载`BeanDefinitions`</span></span><br><span class="line">            loadBeanDefinitions(beanFactory);</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanFactoryMonitor) {</span><br><span class="line">                <span class="comment">// 加锁设置'internal beanFactory'</span></span><br><span class="line">                <span class="keyword">this</span>.beanFactory = beanFactory;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">catch</span> (IOException ex) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(<span class="string">"I/O error parsing bean definition source for "</span> + getDisplayName(), ex);</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure></div><h3 id="closeBeanFactory-和getBeanFactory"><a href="#closeBeanFactory-和getBeanFactory" class="headerlink" title="closeBeanFactory()和getBeanFactory"></a><code>closeBeanFactory()</code>和<code>getBeanFactory</code></h3><p>这两个方法实现都很简单，就是操作<code>refreshBeanFactory()</code>中获得的工厂。</p><h3 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h3><p>其定义了抽象模板方法<code>loadBeanDefinitions</code>供子类定制化实现bean定义的加载。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(DefaultListableBeanFactory beanFactory)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeansException, IOException</span>;</span><br></pre></td></tr></tbody></table></figure></div><h2 id="AbstractRefreshableConfigApplicationContext"><a href="#AbstractRefreshableConfigApplicationContext" class="headerlink" title="AbstractRefreshableConfigApplicationContext"></a>AbstractRefreshableConfigApplicationContext</h2><p>继承<code>AbstractRefreshableConfigApplicationContext</code>，实现了<code>BeanNameAware</code>和<code>InitializingBean</code>。能配置并解析<em>config locations</em>。</p><ul><li><code>setConfigLocations(locations)</code>  设置并解析<em>config locations</em>（会调用<code>resolvePath(String)</code>）</li><li><code>getConfigLocations()</code>  获取<em>config locations</em>，如果没有返回<code>getDefaultConfigLocations()</code>（默认返回null，子类可覆盖）</li><li><code>resolvePath(path)</code> 调用<code>getEnvironment().resolveRequiredPlaceholders(path)</code>来解析路径</li><li><code>setBeanName(name)</code> 如果没有设置过id，会把id设置成<em>beanName</em></li><li><code>afterPropertiesSet()</code> 如果在context构造后，如果context不是激活状态，则调用<code>refresh()</code></li></ul><h2 id="AbstractXmlApplicationContext"><a href="#AbstractXmlApplicationContext" class="headerlink" title="AbstractXmlApplicationContext"></a>AbstractXmlApplicationContext</h2><p>这里用来说明的是<em>xml</em>配置方式，注解方式也大同小异，就是委托的<code>BeanDefinitionReader</code>的不同。下面看<code>loadBeanDefinitions()</code>的实现。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException, IOException </span>{</span><br><span class="line">        <span class="comment">// 为给定工厂，创建XmlBeanDefinitionReader，不同的配置方式使用不用的Reader</span></span><br><span class="line">        XmlBeanDefinitionReader beanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(beanFactory);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 给'beanDefinitionReader'配置Context的资源加载环境</span></span><br><span class="line">        beanDefinitionReader.setEnvironment(<span class="keyword">this</span>.getEnvironment());</span><br><span class="line">        beanDefinitionReader.setResourceLoader(<span class="keyword">this</span>);</span><br><span class="line">        beanDefinitionReader.setEntityResolver(<span class="keyword">new</span> ResourceEntityResolver(<span class="keyword">this</span>));</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 允许子类提供'beanDefinitionReader'的自定义初始化，然后执行实际的`BeanDefinitions`的加载</span></span><br><span class="line">        initBeanDefinitionReader(beanDefinitionReader);</span><br><span class="line">        loadBeanDefinitions(beanDefinitionReader);<span class="comment">// 下面</span></span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(XmlBeanDefinitionReader reader)</span> <span class="keyword">throws</span> BeansException, IOException </span>{</span><br><span class="line">        <span class="comment">// 配置文件可以以`Resource`的形式存在</span></span><br><span class="line">        Resource[] configResources = getConfigResources();</span><br><span class="line">        <span class="keyword">if</span> (configResources != <span class="keyword">null</span>) {</span><br><span class="line">            reader.loadBeanDefinitions(configResources);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 或者以资源路径的形式存在</span></span><br><span class="line">        String[] configLocations = getConfigLocations();</span><br><span class="line">        <span class="keyword">if</span> (configLocations != <span class="keyword">null</span>) {</span><br><span class="line">            reader.loadBeanDefinitions(configLocations);</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure></div><h2 id="ClassPathXmlApplicationContext"><a href="#ClassPathXmlApplicationContext" class="headerlink" title="ClassPathXmlApplicationContext"></a>ClassPathXmlApplicationContext</h2><p>到这一步，是用户可以直接使用的Context了。不同的构造函数代表不同的使用方式。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ClassPathXmlApplicationContext</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            String[] configLocations, <span class="keyword">boolean</span> refresh, <span class="meta">@Nullable</span> ApplicationContext parent)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> BeansException </span>{</span><br><span class="line">        <span class="keyword">super</span>(parent);</span><br><span class="line">        setConfigLocations(configLocations);</span><br><span class="line">        <span class="keyword">if</span> (refresh) {</span><br><span class="line">            refresh();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ClassPathXmlApplicationContext</span><span class="params">(String[] paths, Class&lt;?&gt; clazz, <span class="meta">@Nullable</span> ApplicationContext parent)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> BeansException </span>{</span><br><span class="line">        <span class="keyword">super</span>(parent);</span><br><span class="line">        Assert.notNull(paths, <span class="string">"Path array must not be null"</span>);</span><br><span class="line">        Assert.notNull(clazz, <span class="string">"Class argument must not be null"</span>);</span><br><span class="line">        <span class="keyword">this</span>.configResources = <span class="keyword">new</span> Resource[paths.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; paths.length; i++) {</span><br><span class="line">            <span class="keyword">this</span>.configResources[i] = <span class="keyword">new</span> ClassPathResource(paths[i], clazz);</span><br><span class="line">        }</span><br><span class="line">        refresh();</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
      
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring源码学习—— BeanFactory</title>
      <link href="/2021/10/04/spring-BeanFactory/"/>
      <url>/2021/10/04/spring-BeanFactory/</url>
      
        <content type="html"><![CDATA[<html><head><script src="\assets\js\APlayer.min.js"> </script></head><body><p><code>BeanFactory</code>是Spring框架的核心接口之一，它是bean的容器。类结构图如下（以<code>XmlBeanFactory</code>为例）。</p><p>![image-20210902162721587](/Users/mac/Library/Application Support/typora-user-images/image-20210902162721587.png)</p><p>我们将按照继承关系，从上到下一个个的梳理这些不同类和接口的关系。</p><hr><h2 id="AliasRegistry"><a href="#AliasRegistry" class="headerlink" title="AliasRegistry"></a><code>AliasRegistry</code></h2><p>我们知道在spring中是可以给bean定义一个或多个别名的。而<code>AliasRegistry</code>就是管理别名的通用接口，它定义了给bean**<u>注册、移除、判断、获取</u>**别名的能力。后文我们可以看见其主要是为<code>BeanDefinitionRegistry</code>服务。</p><hr><h2 id="SimpleAliasRegistry"><a href="#SimpleAliasRegistry" class="headerlink" title="SimpleAliasRegistry"></a><code>SimpleAliasRegistry</code></h2><blockquote><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleAliasRegistry</span> <span class="keyword">implements</span> <span class="title">AliasRegistry</span></span></span><br></pre></td></tr></tbody></table></figure></div></blockquote><p><code>AliasRegistry</code>的简单实现类，它有着如下特性：</p><ol><li>使用<code>ConcurrentHashMap</code>作为储存alias和beanName之间的映射关系，”alias-&gt;canonical name”。</li><li>方法<code>cannonicalName(String)</code>返回bean的本名</li><li>修改操作统一加锁（锁为map容器）</li><li>方法<code>allowAliasOverriding()</code>决定是否允许别名覆盖，依赖子类的<code>allowBeanDefinitionOverriding</code>属性</li><li>别名不允许循环，即不能有<code>A-&gt;B</code>且<code>B-&gt;C</code>且<code>C-&gt;A</code></li><li>如果有<code>A-&gt;A</code>，那么会将别名<code>A</code>从容器里删除</li><li>可使用<code>StringValueResolver</code>来处理别名和注册名字符串(no usage)</li></ol><hr><h2 id="SingletonBeanRegistry"><a href="#SingletonBeanRegistry" class="headerlink" title="SingletonBeanRegistry"></a><code>SingletonBeanRegistry</code></h2><p>顶层接口，管理单例bean。定义了注册、获取、判断单例bean以及获取容器锁的方法。<strong>注意，这被注册到里面的bean应该是<u>完全初始化</u>的，不应该执行回调函数（比如生命周期函数）。如果需要执行回调，应该使用BeanFactory注册BeanDefinition。</strong></p><hr><h2 id="DefaultSingletonBeanRegistry"><a href="#DefaultSingletonBeanRegistry" class="headerlink" title="DefaultSingletonBeanRegistry"></a><code>DefaultSingletonBeanRegistry</code></h2><blockquote><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultSingletonBeanRegistry</span> <span class="keyword">extends</span> <span class="title">SimpleAliasRegistry</span> <span class="keyword">implements</span> <span class="title">SingletonBeanRegistry</span></span></span><br></pre></td></tr></tbody></table></figure></div></blockquote><p><code>SingletonBeanRegistry</code>的默认实现。管理着单例bean的注册、获取等；三级实例缓存；单例循环依赖检测；依赖检查等。</p><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><h4 id="三级实例缓存容器（核心）"><a href="#三级实例缓存容器（核心）" class="headerlink" title="三级实例缓存容器（核心）"></a>三级实例缓存容器（核心）</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 缓存fully initialized的单例 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">256</span>);</span><br><span class="line"><span class="comment">/** 缓存ObjectFactory */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">16</span>);</span><br><span class="line"><span class="comment">/** 缓存early instance*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">16</span>);</span><br></pre></td></tr></tbody></table></figure></div><p>这三个map构成了spring加载单例的基础。<u>通过*<code>singletonFactories</code><em>提前暴露bean的<code>ObjectFactory</code>并使用</em><code>earlySingletonObjects</code><em>缓存</em>early instance*，可以解决<strong>属性注入</strong>的循环依赖问题。</u></p><h4 id="循环依赖检测"><a href="#循环依赖检测" class="headerlink" title="循环依赖检测"></a>循环依赖检测</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 标记现在正在创建中的bean name */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; singletonsCurrentlyInCreation = Collections.newSetFromMap(<span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">16</span>));</span><br><span class="line"><span class="comment">/** 创建中不需要检查的bean name */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; inCreationCheckExclusions = Collections.newSetFromMap(<span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">16</span>));</span><br></pre></td></tr></tbody></table></figure></div><p>这两个set用来控制创建中的bean的检查。<u><strong>注意，一般来说，通过它们能够检测到循环依赖，而解决属性注入的循环依赖问题的是暴露创建bean的<code>ObjectFactory</code>，即上面的*<code>singletonFactories</code>*。</strong></u></p><h4 id="bean依赖"><a href="#bean依赖" class="headerlink" title="bean依赖"></a>bean依赖</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** outer bean -&gt; inner bean （外层依赖内层）*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Set&lt;String&gt;&gt; containedBeanMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">16</span>);</span><br><span class="line"><span class="comment">/** depended bean -&gt; dependent bean (谁依赖我)*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Set&lt;String&gt;&gt; dependentBeanMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">64</span>);</span><br><span class="line"><span class="comment">/** dependent bean -&gt; depended bean (我依赖谁) */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Set&lt;String&gt;&gt; dependenciesForBeanMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">64</span>);</span><br></pre></td></tr></tbody></table></figure></div><p>依赖的关系有传递性，即<code>A-&gt;B</code>，<code>B-&gt;C</code>，则<code>A-&gt;C</code>。</p><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul><li>修改三个缓存map需要加锁同步</li><li>能够直接注册单例</li><li>查找单例bean的顺序其一：*<code>singletonObjects</code><em>-&gt;</em><code>earlySingletonObjects</code><em>-&gt;</em><code>singletonFactories</code>*，反过来就是实例的流转顺序。</li><li>查找单例bean的顺序其二：*<code>singletonObjects</code>*-&gt;<em>ObjectFactory&lt;?&gt;</em></li><li>销毁单例bean的顺序：先消除依赖我的bean，再消除自身</li></ul><h3 id="重要方法"><a href="#重要方法" class="headerlink" title="重要方法"></a>重要方法</h3><h4 id="getSingleton——重载之一"><a href="#getSingleton——重载之一" class="headerlink" title="getSingleton——重载之一"></a>getSingleton——重载之一</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, <span class="keyword">boolean</span> allowEarlyReference)</span> </span>{</span><br><span class="line">    <span class="comment">// 先从singletonObjects中寻找</span></span><br><span class="line">    Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">    <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) {</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) {</span><br><span class="line">            <span class="comment">// 如果是正在创建，则在earlySingletonObjects中寻找</span></span><br><span class="line">            singletonObject = <span class="keyword">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">            <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; allowEarlyReference) {</span><br><span class="line">                <span class="comment">// 若还未找到且允许提前初始化，则在singletonFactories中寻找bean的构造工厂</span></span><br><span class="line">                ObjectFactory&lt;?&gt; singletonFactory = <span class="keyword">this</span>.singletonFactories.get(beanName);</span><br><span class="line">                <span class="keyword">if</span> (singletonFactory != <span class="keyword">null</span>) {</span><br><span class="line">                    <span class="comment">// 若找到构造工厂，则创建bean并且放入earlySingletonObjects</span></span><br><span class="line">                    singletonObject = singletonFactory.getObject();</span><br><span class="line">                    <span class="keyword">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">                    <span class="keyword">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 返回的单例可能是完全初始化的，或者是未完全初始化的</span></span><br><span class="line">    <span class="keyword">return</span> singletonObject;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>这个方法主要就是检查缓存，并且在某些条件下将使用<code>ObjectFactory.getObject()</code>创建bean并移入*<code>earlySingltonObjects</code>*。</p><p><strong>这里留个疑问，<code>ObjectFactory</code>是何时放入<code>singletonFactories</code>中的？</strong>这个在下文会有叙述。</p><h4 id="getSingleton——重载之二"><a href="#getSingleton——重载之二" class="headerlink" title="getSingleton——重载之二"></a>getSingleton——重载之二</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> </span>{</span><br><span class="line">        Assert.notNull(beanName, <span class="string">"Bean name must not be null"</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) {</span><br><span class="line">            Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">            <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) { <span class="comment">// 缓存中不存在</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.singletonsCurrentlyInDestruction) {</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationNotAllowedException(beanName,</span><br><span class="line">                            <span class="string">"Singleton bean creation not allowed while singletons of this factory are in destruction "</span> +</span><br><span class="line">                            <span class="string">"(Do not request a bean from a BeanFactory in a destroy method implementation!)"</span>);</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span> (logger.isDebugEnabled()) {</span><br><span class="line">                    logger.debug(<span class="string">"Creating shared instance of singleton bean '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">                }</span><br><span class="line">                <span class="comment">// 标记bean正在创建，并检查</span></span><br><span class="line">                beforeSingletonCreation(beanName);</span><br><span class="line">                <span class="keyword">boolean</span> newSingleton = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">boolean</span> recordSuppressedExceptions = (<span class="keyword">this</span>.suppressedExceptions == <span class="keyword">null</span>);</span><br><span class="line">                <span class="keyword">if</span> (recordSuppressedExceptions) {</span><br><span class="line">                    <span class="keyword">this</span>.suppressedExceptions = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    <span class="comment">// 使用`ObjectFactory`构建singleton</span></span><br><span class="line">                    singletonObject = singletonFactory.getObject();</span><br><span class="line">                    newSingleton = <span class="keyword">true</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">catch</span> (IllegalStateException ex) {</span><br><span class="line">                    <span class="comment">// Has the singleton object implicitly appeared in the meantime -&gt;</span></span><br><span class="line">                    <span class="comment">// if yes, proceed with it since the exception indicates that state.</span></span><br><span class="line">                    singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">                    <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) {</span><br><span class="line">                        <span class="keyword">throw</span> ex;</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">catch</span> (BeanCreationException ex) {</span><br><span class="line">                    <span class="keyword">if</span> (recordSuppressedExceptions) {</span><br><span class="line">                        <span class="keyword">for</span> (Exception suppressedException : <span class="keyword">this</span>.suppressedExceptions) {</span><br><span class="line">                            ex.addRelatedCause(suppressedException);</span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line">                    <span class="keyword">throw</span> ex;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">finally</span> {</span><br><span class="line">                    <span class="keyword">if</span> (recordSuppressedExceptions) {</span><br><span class="line">                        <span class="keyword">this</span>.suppressedExceptions = <span class="keyword">null</span>;</span><br><span class="line">                    }</span><br><span class="line">                    <span class="comment">// 移除bean正在创建标志，并检查</span></span><br><span class="line">                    afterSingletonCreation(beanName);</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span> (newSingleton) {</span><br><span class="line">                    <span class="comment">// 将创建好的bean，加入singleton缓存</span></span><br><span class="line">                    addSingleton(beanName, singletonObject);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> singletonObject;</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure></div><p>这个方法虽然看起来很长，但是多数是异常处理和执行核心逻辑前后的检查操作。其主要工作就是通过<code>ObjectFactory</code>创建bean并放入单例缓存中。</p><hr><h2 id="FactoryBeanRegistrySupport"><a href="#FactoryBeanRegistrySupport" class="headerlink" title="FactoryBeanRegistrySupport"></a><code>FactoryBeanRegistrySupport</code></h2><blockquote><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryBeanRegistrySupport</span> <span class="keyword">extends</span> <span class="title">DefaultSingletonBeanRegistry</span></span></span><br></pre></td></tr></tbody></table></figure></div></blockquote><p>在<code>DefaultSingletonBeanRegistry</code>的基础上，增加了对于<code>FactoryBean</code>的支持。</p><h3 id="缓存FactoryBean创建的单例"><a href="#缓存FactoryBean创建的单例" class="headerlink" title="缓存FactoryBean创建的单例"></a>缓存FactoryBean创建的单例</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** FactoryBean name -&gt; object */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; factoryBeanObjectCache = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">16</span>);</span><br></pre></td></tr></tbody></table></figure></div><p>**<u>这里缓存的是<code>FactoryBean</code>创建的对象，而<code>FactoryBean</code>本身则作为一个单例bean储存在<code>singletonObjects</code>中。</u>**需要注意的是，这里只会缓存单例<code>FactoryBean</code>并且其创建的bean也是单例的。</p><h3 id="重要方法-1"><a href="#重要方法-1" class="headerlink" title="重要方法"></a>重要方法</h3><h4 id="getObjectFromFactoryBean"><a href="#getObjectFromFactoryBean" class="headerlink" title="getObjectFromFactoryBean"></a>getObjectFromFactoryBean</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getObjectFromFactoryBean</span><span class="params">(FactoryBean&lt;?&gt; factory, String beanName, <span class="keyword">boolean</span> shouldPostProcess)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (factory.isSingleton() &amp;&amp; containsSingleton(beanName)) {</span><br><span class="line">          <span class="comment">// 如果是单例bean，并且singletonObjects中含有该FactoryBean</span></span><br><span class="line">            <span class="keyword">synchronized</span> (getSingletonMutex()) {</span><br><span class="line">                <span class="comment">// 先尝试从缓存factoryBeanObjectCache中获取</span></span><br><span class="line">                Object object = <span class="keyword">this</span>.factoryBeanObjectCache.get(beanName);</span><br><span class="line">                <span class="keyword">if</span> (object == <span class="keyword">null</span>) {</span><br><span class="line">                    <span class="comment">// 缓存中没有，则通过Factory.getObject()获取；若是null，则会返回NullBean</span></span><br><span class="line">                    object = doGetObjectFromFactoryBean(factory, beanName);</span><br><span class="line">                    <span class="comment">// 在上面的getObject()调用期间，bean可能通过其他方式加入了缓存，故需要再次检查</span></span><br><span class="line">                  <span class="comment">// 这么做的目的是，保证单例bean的后置处理只应用一次</span></span><br><span class="line">                    Object alreadyThere = <span class="keyword">this</span>.factoryBeanObjectCache.get(beanName);</span><br><span class="line">                    <span class="keyword">if</span> (alreadyThere != <span class="keyword">null</span>) {</span><br><span class="line">                        object = alreadyThere;</span><br><span class="line">                    }</span><br><span class="line">                    <span class="keyword">else</span> {</span><br><span class="line">                        <span class="keyword">if</span> (shouldPostProcess) {</span><br><span class="line">                            <span class="keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) {</span><br><span class="line">                                <span class="comment">// 正在创建中，临时返回对象（未后置处理和储存）</span></span><br><span class="line">                                <span class="keyword">return</span> object;</span><br><span class="line">                            }</span><br><span class="line">                            <span class="comment">// 标记正在创建</span></span><br><span class="line">                            beforeSingletonCreation(beanName);</span><br><span class="line">                            <span class="keyword">try</span> {</span><br><span class="line">                                <span class="comment">// FactoryBean创建的bean后置处理，比如aop代理等</span></span><br><span class="line">                                object = postProcessObjectFromFactoryBean(object, beanName);</span><br><span class="line">                            }</span><br><span class="line">                            <span class="keyword">catch</span> (Throwable ex) {</span><br><span class="line">                                <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName,</span><br><span class="line">                                        <span class="string">"Post-processing of FactoryBean's singleton object failed"</span>, ex);</span><br><span class="line">                            }</span><br><span class="line">                            <span class="keyword">finally</span> {</span><br><span class="line">                                <span class="comment">// 移除正在创建标记</span></span><br><span class="line">                                afterSingletonCreation(beanName);</span><br><span class="line">                            }</span><br><span class="line">                        }</span><br><span class="line">                        <span class="keyword">if</span> (containsSingleton(beanName)) {</span><br><span class="line">                            <span class="comment">// 加入缓存</span></span><br><span class="line">                            <span class="keyword">this</span>.factoryBeanObjectCache.put(beanName, object);</span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">return</span> object;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// 如果实例本身或者FactoryBean不是单例，则每次获取都要调用Factory.getObject()，并且应用后置处理</span></span><br><span class="line">            Object object = doGetObjectFromFactoryBean(factory, beanName);</span><br><span class="line">            <span class="keyword">if</span> (shouldPostProcess) {</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                  <span class="comment">// 后置处理</span></span><br><span class="line">                    object = postProcessObjectFromFactoryBean(object, beanName);</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">catch</span> (Throwable ex) {</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName, <span class="string">"Post-processing of FactoryBean's object failed"</span>, ex);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> object;</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure></div><p>总体上看，就是先区分是否是单例。若是单例，则通过<code>FactoryBean</code>获取单例，并应用后置处理，需要注意的是单例bean 后置处理只能应用一次，之后加入缓存，下一次获取则通过缓存。若不是单例，则每次都通过<code>FactoryBean</code>获取，并应用后置处理。</p><hr><h2 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a><code>BeanFactory</code></h2><p><code>BeanFactory</code>接口是整个<em>bean factory</em>体系的顶层接口，也是我们属性的“spring容器”，它管理着所有的bean。<strong>说一个bean存在于<code>BeanFactory</code>，它可能是bean definition或singleton实例，也可能存在于当前工厂或者是父工厂。</strong>它还要求实现类应该要满足下面的bean生命周期。</p><h3 id="bean的初始化生命周期顺序"><a href="#bean的初始化生命周期顺序" class="headerlink" title="bean的初始化生命周期顺序"></a>bean的初始化生命周期顺序</h3><ol><li><code>BeanNameAware.setBeanName(String)</code></li><li><code>BeanClassLoaderAware.setBeanClassLoader(ClassLoader)</code></li><li><code>BeanFactoryAware.setBeanFactory(BeanFactory)</code></li><li><code>EnvironmentAware.setEnvironment(Environment)</code></li><li><code>EmbeddedValueResolverAware.setEmbeddedValueResolver(StringValueResolver)</code></li><li>*<code>ResourceLoaderAware.setResourceLoader(ResourceLoader)</code></li><li>*<code>ApplicationEventPublisherAware.setApplicationEventPublisher(ApplicationEventPublisher)</code></li><li>*<code>MessageSourceAware.setMessageSource(MessageSource)</code></li><li>*<code>ApplicationContextAware.setApplicationContext(ApplicationContext)</code></li><li>**<code>ServletContextAware.setServletContext(ServletContext)</code></li><li><code>BeanPostProcessor.postProcessBeforeInitialization(Object, String)</code>（<code>@PostConstruct</code>在其中）</li><li><code>InitializingBean.afterPropertiesSet()</code></li><li><em>a custom init-method definition</em></li><li><code>BeanPostProcessor.postProcessAfterInitialization(Object, String)</code></li></ol><h3 id="bean的销毁生命周期顺序"><a href="#bean的销毁生命周期顺序" class="headerlink" title="bean的销毁生命周期顺序"></a>bean的销毁生命周期顺序</h3><ol><li><code>DestructionAwareBeanPostProcessor.postProcessBeforeDestruction(Object, String)</code>(<code>@PreDestroy</code>在其中)</li><li><code>DisposableBean.destroy()</code></li><li><em>a custom destroy-method definition</em></li></ol><hr><h2 id="HierarchicalBeanFactory"><a href="#HierarchicalBeanFactory" class="headerlink" title="HierarchicalBeanFactory"></a><code>HierarchicalBeanFactory</code></h2><blockquote><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HierarchicalBeanFactory</span> <span class="keyword">extends</span> <span class="title">BeanFactory</span></span></span><br></pre></td></tr></tbody></table></figure></div></blockquote><p><code>HierarchicalBeanFactory</code>在<code>BeanFactory</code>的基础上引入了容器继承体系。</p><hr><h2 id="ConfigurableBeanFactory"><a href="#ConfigurableBeanFactory" class="headerlink" title="ConfigurableBeanFactory"></a><code>ConfigurableBeanFactory</code></h2><blockquote><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConfigurableBeanFactory</span> <span class="keyword">extends</span> <span class="title">HierarchicalBeanFactory</span>, <span class="title">SingletonBeanRegistry</span></span></span><br></pre></td></tr></tbody></table></figure></div></blockquote><p><code>ConfigurableBeanFactory</code>提供了一系列配置bean容器的接口，主要由spring框架自身使用。它有如下功能：</p><ol><li>设置<em>parentBeanFactory</em>，只能设置一次，而且尽可能使用构造器初始化</li><li>设置<em>beanClassLoader</em></li><li>设置<em>tempClassLoader</em>，用于类型匹配，通常只在<em>weaving</em>使用，一旦<code>BeanFactory</code>完成启动阶段就会被删除</li><li>设置<em>cacheBeanMetadata</em>，是否缓存<em>bean</em>的元数据，如<em>bean definitions</em>和<em>resolved bean classes</em>，默认开启</li><li>设置<code>BeanExpressionResolver</code>，如<code>"#{...}"</code>解析器</li><li>设置<code>ConversionService</code></li><li>添加<code>PropertyEditorRegistrar</code>，用于所有bean的创建过程</li><li>注册<em>customerEditor</em>（<code>PropertyEditor</code>）</li><li>设置<code>TypeConverter</code>，用于转化bean的属性值类型、构造参数类型等</li><li>添加<em>embeddedValueResolver</em>（<code>StringValueResolver</code>）</li><li>添加<code>BeanPostProcessor</code>，<strong>调用顺序和加入顺序相同，忽略<code>Ordered</code>接口，手动添加的先于自动发现的</strong></li><li>注册<code>Scope</code></li><li>复制配置</li><li>注册、解析别名</li><li>获取<em>mergedBeanDefinition</em></li><li>判断是否是<code>FactoryBean</code></li><li>标记正在创建中的bean</li><li>注册依赖的bean</li><li>销毁指定bean</li><li>销毁所有单例</li></ol><hr><h2 id="AbstractBeanFactory"><a href="#AbstractBeanFactory" class="headerlink" title="AbstractBeanFactory"></a><code>AbstractBeanFactory</code></h2><blockquote><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractBeanFactory</span> <span class="keyword">extends</span> <span class="title">FactoryBeanRegistrySupport</span> <span class="keyword">implements</span> <span class="title">ConfigurableBeanFactory</span></span></span><br></pre></td></tr></tbody></table></figure></div></blockquote><p><code>AbstractBeanFactory</code>提供了<code>ConfigurableBeanFactory</code>接口定义的能力。提供单例bean缓存、singleton/prototype类型判定、<code>FactoryBean</code>处理、别名、bean定义合并、bean销毁、父子容器等。提供给子类实现的主要模板方法是<code>getBeanDefinition()</code>和<code>createBean()</code>。</p><h3 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span> <span class="comment">/** 父bean工厂 */</span></span><br><span class="line"><span class="keyword">private</span> BeanFactory parentBeanFactory;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span> <span class="comment">/** bean的类加载器  */</span></span><br><span class="line"><span class="keyword">private</span> ClassLoader beanClassLoader = ClassUtils.getDefaultClassLoader();</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span> <span class="comment">/** 临时类加载器，用于在必要的时候解析bean class name */</span></span><br><span class="line"><span class="keyword">private</span> ClassLoader tempClassLoader;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 是否缓存bean的元数据，而不是每次都重新获取 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> cacheBeanMetadata = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span> <span class="comment">/** bean定义中值的表达式解析策略 */</span></span><br><span class="line"><span class="keyword">private</span> BeanExpressionResolver beanExpressionResolver;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span> <span class="comment">/** Spring的ConversionService，用于替代PropertyEditors. */</span></span><br><span class="line"><span class="keyword">private</span> ConversionService conversionService;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 自定义的PropertyEditorRegistrars，用于应用于这个bean工厂中的bean */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Set&lt;PropertyEditorRegistrar&gt; propertyEditorRegistrars = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 自定义的PropertyEditors，用于应用于这个bean工厂中的bean */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, Class&lt;? extends PropertyEditor&gt;&gt; customEditors = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span> <span class="comment">/** 自定义的TypeConverter，用于覆盖默认的PropertyEditor机制 */</span></span><br><span class="line"><span class="keyword">private</span> TypeConverter typeConverter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** StringValueResolver用于解析<span class="doctag">@Value</span>("xxx")等 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;StringValueResolver&gt; embeddedValueResolvers = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">/** bean后置处理器 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;BeanPostProcessor&gt; beanPostProcessors = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 标记是否有InstantiationAwareBeanPostProcessors被注册 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> hasInstantiationAwareBeanPostProcessors;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 标记是否有DestructionAwareBeanPostProcessors被注册 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> hasDestructionAwareBeanPostProcessors;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 注册的scope */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Scope&gt; scopes = <span class="keyword">new</span> LinkedHashMap&lt;&gt;(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span> <span class="comment">/** Security context used when running with a SecurityManager. */</span></span><br><span class="line"><span class="keyword">private</span> SecurityContextProvider securityContextProvider;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** bean名称 -&gt; 合并的bean定义 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, RootBeanDefinition&gt; mergedBeanDefinitions = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">256</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 至少创建过一次的bean名称集合 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; alreadyCreated = Collections.newSetFromMap(<span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">256</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 当前线程正在创建的bean名称 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ThreadLocal&lt;Object&gt; prototypesCurrentlyInCreation = <span class="keyword">new</span> NamedThreadLocal&lt;&gt;(<span class="string">"Prototype beans currently in creation"</span>);</span><br></pre></td></tr></tbody></table></figure></div><p>可以看到其中的属性大多是为了实现<code>ConfigurableBeanFactory</code>中定义的功能而使用的。</p><h3 id="特性-1"><a href="#特性-1" class="headerlink" title="特性"></a>特性</h3><ol><li>完全提供了<code>ConfigurableBeanFactory</code>规定的能力</li><li><code>doGetBean()</code>为核心方法，处理了普通bean和<code>FactoryBean</code>，分析见下文</li><li><code>createBean()</code>和<code>getBeanDefinition()</code>为模板方法，供子类实现</li><li>如果bean存在于工厂中，是指存在当前工厂或父工厂，其形态可能是bean定义也可能是单例bean</li><li>一个bean是单例，指的是它本身是单例的，如果它是通过<code>FactoryBean</code>构建的，那么<code>FactoryBean.isSingleton()</code>应该返回单例</li><li><code>isTypeMatch()</code>较为复杂，需要考虑所有可能的情况</li><li><code>BeanPostProcessor</code>按照添加的顺序调用，忽略<code>Ordered</code>接口</li><li><code>containsBean()</code>考虑父工厂，而<code>containsBeanDefinition()</code>只考虑当前工厂。</li></ol><h3 id="重要方法-2"><a href="#重要方法-2" class="headerlink" title="重要方法"></a>重要方法</h3><h4 id="getBean（doGetBean）"><a href="#getBean（doGetBean）" class="headerlink" title="getBean（doGetBean）"></a>getBean（doGetBean）</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(String name, Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException </span>{</span><br><span class="line">    <span class="keyword">return</span> doGetBean(name, requiredType, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">doGetBean</span><span class="params">(<span class="keyword">final</span> String name, <span class="meta">@Nullable</span> <span class="keyword">final</span> Class&lt;T&gt; requiredType,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="meta">@Nullable</span> <span class="keyword">final</span> Object[] args, <span class="keyword">boolean</span> typeCheckOnly)</span> <span class="keyword">throws</span> BeansException </span>{</span><br><span class="line">    <span class="comment">// 转换名称：FactoryBean去除'&amp;'，别名转化成本名</span></span><br><span class="line">    <span class="keyword">final</span> String beanName = transformedBeanName(name);</span><br><span class="line">    Object bean;</span><br><span class="line">    <span class="comment">// 先在三级缓存中寻找</span></span><br><span class="line">    Object sharedInstance = getSingleton(beanName);</span><br><span class="line">    <span class="keyword">if</span> (sharedInstance != <span class="keyword">null</span> &amp;&amp; args == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) {</span><br><span class="line">            <span class="keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) {</span><br><span class="line">                logger.trace(<span class="string">"Returning eagerly cached instance of singleton bean '"</span> + beanName +</span><br><span class="line">                        <span class="string">"' that is not fully initialized yet - a consequence of a circular reference"</span>);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> {</span><br><span class="line">                logger.trace(<span class="string">"Returning cached instance of singleton bean '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 如果三级缓存中已经存在且没有指定构造参数，则从sharedInstance中获取bean，此方法见后文</span></span><br><span class="line">        bean = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="keyword">null</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 一般来说第一次创建会走下面的else</span></span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// 检测prototype类型的bean是否存在循环依赖</span></span><br><span class="line">        <span class="keyword">if</span> (isPrototypeCurrentlyInCreation(beanName)) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName);</span><br><span class="line">        }</span><br><span class="line">  </span><br><span class="line">        BeanFactory parentBeanFactory = getParentBeanFactory();</span><br><span class="line">        <span class="comment">// 注意这里的条件判断的后半部分</span></span><br><span class="line">        <span class="keyword">if</span> (parentBeanFactory != <span class="keyword">null</span> &amp;&amp; !containsBeanDefinition(beanName)) {</span><br><span class="line">            <span class="comment">// 走到此，如果当前factory不存在bean定义，且父类工厂不为空，则在父工厂中寻找</span></span><br><span class="line">            <span class="comment">// 根据条件调用不同版本的getBean()方法</span></span><br><span class="line">            String nameToLookup = originalBeanName(name);</span><br><span class="line">            <span class="keyword">if</span> (parentBeanFactory <span class="keyword">instanceof</span> AbstractBeanFactory) {</span><br><span class="line">                <span class="keyword">return</span> ((AbstractBeanFactory) parentBeanFactory).doGetBean(</span><br><span class="line">                        nameToLookup, requiredType, args, typeCheckOnly);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (args != <span class="keyword">null</span>) {</span><br><span class="line">                <span class="keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup, args);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (requiredType != <span class="keyword">null</span>) {</span><br><span class="line">                <span class="keyword">return</span> parentBeanFactory.getBean(nameToLookup, requiredType);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> (!typeCheckOnly) {</span><br><span class="line">            <span class="comment">// 如果获取bean的目的是实际使用而不仅是类型检查，标记此bean为已创建的</span></span><br><span class="line">            markBeanAsCreated(beanName);</span><br><span class="line">        }</span><br><span class="line">  </span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">// 获取合并的bean定义，将BeanDefinition转为RootBeanDefinition</span></span><br><span class="line">            <span class="keyword">final</span> RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">            checkMergedBeanDefinition(mbd, beanName, args);</span><br><span class="line">  </span><br><span class="line">            <span class="comment">// 获取depends-on属性上的值，并保证被依赖的bean先初始化</span></span><br><span class="line">            <span class="comment">// 注意，这里是depends-on属性上的配置值，不是bean的依赖（比如autowired等）</span></span><br><span class="line">            String[] dependsOn = mbd.getDependsOn();</span><br><span class="line">            <span class="keyword">if</span> (dependsOn != <span class="keyword">null</span>) {</span><br><span class="line">                <span class="keyword">for</span> (String dep : dependsOn) {</span><br><span class="line">                    <span class="keyword">if</span> (isDependent(beanName, dep)) {</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">                                <span class="string">"Circular depends-on relationship between '"</span> + beanName + <span class="string">"' and '"</span> + dep + <span class="string">"'"</span>);</span><br><span class="line">                    }</span><br><span class="line">                    registerDependentBean(dep, beanName);</span><br><span class="line">                    <span class="keyword">try</span> {</span><br><span class="line">                        getBean(dep);</span><br><span class="line">                    }</span><br><span class="line">                    <span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) {</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">                                <span class="string">"'"</span> + beanName + <span class="string">"' depends on missing bean '"</span> + dep + <span class="string">"'"</span>, ex);</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">  </span><br><span class="line">            <span class="comment">// 接下来就是创建bean实例了</span></span><br><span class="line">            <span class="keyword">if</span> (mbd.isSingleton()) {</span><br><span class="line">                <span class="comment">// 这里调用的是getSingleton重载方法之一，上文有介绍</span></span><br><span class="line">                sharedInstance = getSingleton(beanName, () -&gt; {</span><br><span class="line">                    <span class="keyword">try</span> {</span><br><span class="line">                        <span class="comment">// createBean()方法很重要，其代码实现在AbstractAutowireCapableBeanFactory中，</span></span><br><span class="line">                        <span class="comment">// 后文会详细介绍，这里只要知道它创建并返回了一个bean（可能是FactoryBean）</span></span><br><span class="line">                        <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">                    }</span><br><span class="line">                    <span class="keyword">catch</span> (BeansException ex) {</span><br><span class="line">                        destroySingleton(beanName);</span><br><span class="line">                        <span class="keyword">throw</span> ex;</span><br><span class="line">                    }</span><br><span class="line">                });</span><br><span class="line">                <span class="comment">// sharedInstance可能是普通bean也可能是FactoryBean，此处理方法见下文</span></span><br><span class="line">                bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">            }</span><br><span class="line">  </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (mbd.isPrototype()) {</span><br><span class="line">                <span class="comment">// prototype类型的bean创建</span></span><br><span class="line">                Object prototypeInstance = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    <span class="comment">// 标记为正在创建的prototype类型的bean（通过prototypesCurrentlyInCreation属性）</span></span><br><span class="line">                    beforePrototypeCreation(beanName);</span><br><span class="line">                    <span class="comment">// 同样要调用createBean()方法</span></span><br><span class="line">                    prototypeInstance = createBean(beanName, mbd, args);</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">finally</span> {</span><br><span class="line">                    <span class="comment">// 移除bean的正在创建的prototype类型的标志</span></span><br><span class="line">                    afterPrototypeCreation(beanName);</span><br><span class="line">                }</span><br><span class="line">                bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br><span class="line">            }</span><br><span class="line">  </span><br><span class="line">            <span class="keyword">else</span> {</span><br><span class="line">                <span class="comment">// 其他scope类型的bean创建</span></span><br><span class="line">                String scopeName = mbd.getScope();</span><br><span class="line">                <span class="keyword">final</span> Scope scope = <span class="keyword">this</span>.scopes.get(scopeName);</span><br><span class="line">                <span class="keyword">if</span> (scope == <span class="keyword">null</span>) {</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No Scope registered for scope name '"</span> + scopeName + <span class="string">"'"</span>);</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    Object scopedInstance = scope.get(beanName, () -&gt; {</span><br><span class="line">                        beforePrototypeCreation(beanName);</span><br><span class="line">                        <span class="keyword">try</span> {</span><br><span class="line">                            <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">                        }</span><br><span class="line">                        <span class="keyword">finally</span> {</span><br><span class="line">                            afterPrototypeCreation(beanName);</span><br><span class="line">                        }</span><br><span class="line">                    });</span><br><span class="line">                    bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">catch</span> (IllegalStateException ex) {</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName,</span><br><span class="line">                            <span class="string">"Scope '"</span> + scopeName + <span class="string">"' is not active for the current thread; consider "</span> +</span><br><span class="line">                            <span class="string">"defining a scoped proxy for this bean if you intend to refer to it from a singleton"</span>,</span><br><span class="line">                            ex);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">catch</span> (BeansException ex) {</span><br><span class="line">            <span class="comment">// 发生异常，移除该bean的已创建标志（从alreadyCreated中移除）</span></span><br><span class="line">            cleanupAfterBeanCreationFailure(beanName);</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 检查需要的类型是否和bean instance的实际类型匹配</span></span><br><span class="line">    <span class="keyword">if</span> (requiredType != <span class="keyword">null</span> &amp;&amp; !requiredType.isInstance(bean)) {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">// bean的实际类型不匹配，需要使用TypeConverter转换成指定类型，否则会抛异常</span></span><br><span class="line">            T convertedBean = getTypeConverter().convertIfNecessary(bean, requiredType);</span><br><span class="line">            <span class="keyword">if</span> (convertedBean == <span class="keyword">null</span>) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> convertedBean;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">catch</span> (TypeMismatchException ex) {</span><br><span class="line">            <span class="keyword">if</span> (logger.isTraceEnabled()) {</span><br><span class="line">                logger.trace(<span class="string">"Failed to convert bean '"</span> + name + <span class="string">"' to required type '"</span> +</span><br><span class="line">                        ClassUtils.getQualifiedName(requiredType) + <span class="string">"'"</span>, ex);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> (T) bean;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>可以看到<code>doGetBean()</code>方法还是很长，好在逻辑层次很清晰。先是从单例缓存中寻找；再是如果当前工厂不含有该bean定义且父工厂不为空则委托父工厂获取bean；再是保证bean定义中<em>depends-on</em>上的依赖都先于此bean初始化；然后就是根据bean的scope类型获取bean（都需要经过<code>createBean()</code>方法创建）；最后就是根据需要是否转换bean的Class类型。</p><p>上面获取的<em>sharedInstance</em>可能是普通bean或者是<code>FactoryBean</code>，都需要经过<code>getObjectForBeanInstance()</code>的处理。</p><h4 id="getObjectForBeanInstance"><a href="#getObjectForBeanInstance" class="headerlink" title="getObjectForBeanInstance"></a>getObjectForBeanInstance</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 从给定的beanInstance参数中获取bean，beanInstance可以是bean本身，也可能是个FactoryBean */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getObjectForBeanInstance</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            Object beanInstance, String name, String beanName, <span class="meta">@Nullable</span> RootBeanDefinition mbd)</span> </span>{</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 用户通过名称'&amp;xxx'想要获取FactoryBean本身，如果beanInstance不是一个FactoryBean，则会抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (BeanFactoryUtils.isFactoryDereference(name)) {</span><br><span class="line">            <span class="keyword">if</span> (beanInstance <span class="keyword">instanceof</span> NullBean) {</span><br><span class="line">                <span class="keyword">return</span> beanInstance;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (!(beanInstance <span class="keyword">instanceof</span> FactoryBean)) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BeanIsNotAFactoryException(beanName, beanInstance.getClass());</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (mbd != <span class="keyword">null</span>) {</span><br><span class="line">                mbd.isFactoryBean = <span class="keyword">true</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> beanInstance;</span><br><span class="line">        }</span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 到这里我们可以确定用户要获取的是bean对象</span></span><br><span class="line">        <span class="comment">// 如果beanInstance是FactoryBean，则我们使用它来创建bean;</span></span><br><span class="line">        <span class="comment">// 否则beanInstance本身就是bean，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (!(beanInstance <span class="keyword">instanceof</span> FactoryBean)) {</span><br><span class="line">            <span class="keyword">return</span> beanInstance;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// beanInstance是一个FactoryBean</span></span><br><span class="line">        Object object = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (mbd != <span class="keyword">null</span>) {</span><br><span class="line">            mbd.isFactoryBean = <span class="keyword">true</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// 从缓存中获取FactoryBean创建的对象</span></span><br><span class="line">            object = getCachedObjectForFactoryBean(beanName);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (object == <span class="keyword">null</span>) {</span><br><span class="line">            <span class="comment">// 程序到这里表明需要从FactoryBean中构建bean</span></span><br><span class="line">            FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) beanInstance;</span><br><span class="line">            <span class="keyword">if</span> (mbd == <span class="keyword">null</span> &amp;&amp; containsBeanDefinition(beanName)) {</span><br><span class="line">                <span class="comment">// 获取合并的bean定义，会将BeanDefiniton转换成RootBeanDefinition</span></span><br><span class="line">                mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">boolean</span> synthetic = (mbd != <span class="keyword">null</span> &amp;&amp; mbd.isSynthetic());</span><br><span class="line">            <span class="comment">// 从FactoryBean中获取对象，包括后置处理等，上文有详细分析</span></span><br><span class="line">            object = getObjectFromFactoryBean(factory, beanName, !synthetic);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 返回FactoryBean中的bean实例</span></span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure></div><p>这里处理的逻辑很清楚，根据调用参数是否有<code>&amp;</code>前缀判断用户是想要的是<code>FactoryBean</code>本身还是其构建的bean，然后根据<em>beanInstance</em>是普通bean还是<code>FactoryBean</code>的情况区分。</p><p><strong>这里值得注意的是，如果是<code>FactoryBean</code>那么获取bean的时候会调用<code>getObjectFromFactoryBean</code>，这个方法会有bean的后置处理；那么如果是普通bean呢？</strong>猜测普通bean是在<code>createBean()</code>那一步进行了后置处理，这里先留个疑问。</p><hr><h2 id="AutowireCapableBeanFactory"><a href="#AutowireCapableBeanFactory" class="headerlink" title="AutowireCapableBeanFactory"></a><code>AutowireCapableBeanFactory</code></h2><blockquote><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AutowireCapableBeanFactory</span> <span class="keyword">extends</span> <span class="title">BeanFactory</span></span></span><br></pre></td></tr></tbody></table></figure></div></blockquote><p>扩展了自动装配的能力。</p><h3 id="特性："><a href="#特性：" class="headerlink" title="特性："></a>特性：</h3><ul><li>该接口主要供spring框架内部使用</li><li>注意<code>ApplicationContext</code>并没有实现此接口，但有<code>getAutowireCapableBeanFactory()</code>方法</li><li><code>BeanFactoryAware</code>传入的工厂可通过强制转换成<code>AutowireCapableBeanFactory</code></li><li>有<code>createBean()</code>、<code>autowireBean()</code>、<code>configureBean()</code>方法</li><li>有<code>initializeBean()</code>、<code>applyBeanPostProcessorsBeforeInitialization()</code>、<code>applyBeanPostProcessorsAfterInitialization()</code>和<code>destroyBean</code>等方法</li></ul><hr><h2 id="AbstractAutowireCapableBeanFactory"><a href="#AbstractAutowireCapableBeanFactory" class="headerlink" title="AbstractAutowireCapableBeanFactory"></a><code>AbstractAutowireCapableBeanFactory</code></h2><blockquote><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractAutowireCapableBeanFactory</span> <span class="keyword">extends</span> <span class="title">AbstractBeanFactory</span></span></span><br><span class="line"><span class="class">      <span class="keyword">implements</span> <span class="title">AutowireCapableBeanFactory</span></span></span><br></pre></td></tr></tbody></table></figure></div></blockquote><p>在<code>AbstractBeanFactory</code>的能力上实现了<code>AutowireCapableBeanFactory</code>接口，提供了bean创建、属性填充、装配、初始化、处理运行时bean引用、调用初始化方法等。支持通过构造器注入、属性注入（名称或类型）。该类的在实现上较为复杂，因为是实际上创建bean的地方，需要考虑各种情况以及兼顾各种扩展点。</p><h3 id="特性-2"><a href="#特性-2" class="headerlink" title="特性"></a>特性</h3><ol><li>可指定实例化bean的策略，默认是<code>CglibSubclassingInstantiationStrategy</code></li><li>方法参数名称解析策略</li><li>可设置依赖检查或者自动注入中被忽略的类型或者接口</li><li>缓存未完成的<code>FactoryBean</code>实例（<code>BeanWrapper</code>）</li><li>缓存每个工厂类的候选工厂方法</li><li>缓存筛选的<code>PropertyDescriptors</code></li></ol><h3 id="重要方法-3"><a href="#重要方法-3" class="headerlink" title="重要方法"></a>重要方法</h3><h4 id="createBean"><a href="#createBean" class="headerlink" title="createBean"></a>createBean</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此类的中心方法，创建一个bean实例并填充，应用后置处理等</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">createBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> BeanCreationException </span>{</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (logger.isTraceEnabled()) {</span><br><span class="line">        logger.trace(<span class="string">"Creating instance of bean '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">    }</span><br><span class="line">    RootBeanDefinition mbdToUse = mbd;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 解析Class</span></span><br><span class="line">    <span class="comment">// 在动态解析Class的情况下，克隆bean定义</span></span><br><span class="line">    Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName);</span><br><span class="line">    <span class="keyword">if</span> (resolvedClass != <span class="keyword">null</span> &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != <span class="keyword">null</span>) {</span><br><span class="line">        mbdToUse = <span class="keyword">new</span> RootBeanDefinition(mbd);</span><br><span class="line">        mbdToUse.setBeanClass(resolvedClass);</span><br><span class="line">    }</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">      <span class="comment">// 准备方法覆盖(lookup-method和replace-method)</span></span><br><span class="line">        mbdToUse.prepareMethodOverrides();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">catch</span> (BeanDefinitionValidationException ex) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(mbdToUse.getResourceDescription(),</span><br><span class="line">                beanName, <span class="string">"Validation of method overrides failed"</span>, ex);</span><br><span class="line">    }</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 给与BeanPostProcessors一个机会返回代理对象而不是实例本身(InstantiationAwareBeanPostProcessor)</span></span><br><span class="line">        Object bean = resolveBeforeInstantiation(beanName, mbdToUse);</span><br><span class="line">        <span class="keyword">if</span> (bean != <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> bean;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbdToUse.getResourceDescription(), beanName,</span><br><span class="line">                <span class="string">"BeanPostProcessor before instantiation of bean failed"</span>, ex);</span><br><span class="line">    }</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">      <span class="comment">// 若bean没有被代理，创建bean实例本身</span></span><br><span class="line">        Object beanInstance = doCreateBean(beanName, mbdToUse, args);</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) {</span><br><span class="line">            logger.trace(<span class="string">"Finished creating instance of bean '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> beanInstance;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">catch</span> (BeanCreationException | ImplicitlyAppearedSingletonException ex) {</span><br><span class="line">        <span class="comment">// A previously detected exception with proper bean creation context already,</span></span><br><span class="line">        <span class="comment">// or illegal singleton state to be communicated up to DefaultSingletonBeanRegistry.</span></span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">                mbdToUse.getResourceDescription(), beanName, <span class="string">"Unexpected exception during bean creation"</span>, ex);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>此方法没太复杂的逻辑，创建的逻辑都委托给了<code>doCreateBean</code>方法，而在创建前给与<code>InstantiationAwareBeanPostProcessor</code>一个机会返回代理对象而不是实例本身。</p><h4 id="doCreateBean"><a href="#doCreateBean" class="headerlink" title="doCreateBean"></a>doCreateBean</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> <span class="meta">@Nullable</span> Object[] args)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeanCreationException </span>{</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化bean</span></span><br><span class="line">BeanWrapper instanceWrapper = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (mbd.isSingleton()) {</span><br><span class="line">      <span class="comment">// 检查是否有FactoryBean的BeanWrapper缓存（缓存是在类型检查的时候生成）</span></span><br><span class="line">instanceWrapper = <span class="keyword">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) {</span><br><span class="line">      <span class="comment">// 缓存中没有，使用实例化策略（工厂方法、构造器注入等），创建指定bean的实例</span></span><br><span class="line">instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">final</span> Object bean = instanceWrapper.getWrappedInstance();</span><br><span class="line">Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();</span><br><span class="line"><span class="keyword">if</span> (beanType != NullBean.class) {</span><br><span class="line">mbd.resolvedTargetType = beanType;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allow post-processors to modify the merged bean definition.</span></span><br><span class="line"><span class="keyword">synchronized</span> (mbd.postProcessingLock) {</span><br><span class="line"><span class="keyword">if</span> (!mbd.postProcessed) {</span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line">          <span class="comment">// 应用MergedBeanDefinitionPostProcessor</span></span><br><span class="line">applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) {</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line"><span class="string">"Post-processing of merged bean definition failed"</span>, ex);</span><br><span class="line">}</span><br><span class="line">mbd.postProcessed = <span class="keyword">true</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否需要提前曝光未初始化完全的对象</span></span><br><span class="line"><span class="keyword">boolean</span> earlySingletonExposure = (mbd.isSingleton() &amp;&amp; <span class="keyword">this</span>.allowCircularReferences &amp;&amp;</span><br><span class="line">isSingletonCurrentlyInCreation(beanName));</span><br><span class="line"><span class="keyword">if</span> (earlySingletonExposure) {</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) {</span><br><span class="line">logger.trace(<span class="string">"Eagerly caching bean '"</span> + beanName +</span><br><span class="line"><span class="string">"' to allow for resolving potential circular references"</span>);</span><br><span class="line">}</span><br><span class="line">      <span class="comment">// 将未初始化完全的bean实例放入ObjectFactory中（第三级缓存），</span></span><br><span class="line">      <span class="comment">// getEarlyBeanReference方法主要应用SmartInstantiationAwareBeanPostProcessor.getEarlyBeanReference方法</span></span><br><span class="line">      <span class="comment">// 我们熟知的aop就是在这里进行织入的</span></span><br><span class="line">addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize the bean instance.</span></span><br><span class="line">Object exposedObject = bean;</span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line">      <span class="comment">// 对bean的各项属性进行填充注入</span></span><br><span class="line">populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">      <span class="comment">// 调用初始化方法：invokeAwareMethods-&gt;postProcessBeforeInitialization-&gt;init-method-&gt;postProcessAfterInitialization</span></span><br><span class="line">exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) {</span><br><span class="line"><span class="keyword">if</span> (ex <span class="keyword">instanceof</span> BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) {</span><br><span class="line"><span class="keyword">throw</span> (BeanCreationException) ex;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> {</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">mbd.getResourceDescription(), beanName, <span class="string">"Initialization of bean failed"</span>, ex);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 这里检测循环依赖</span></span><br><span class="line"><span class="keyword">if</span> (earlySingletonExposure) {</span><br><span class="line">Object earlySingletonReference = getSingleton(beanName, <span class="keyword">false</span>);</span><br><span class="line">      <span class="comment">// earlySingletonReference只有在检测到循环依赖的情况下才不为空</span></span><br><span class="line"><span class="keyword">if</span> (earlySingletonReference != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="comment">// 如果exposedObject没有被增强</span></span><br><span class="line"><span class="keyword">if</span> (exposedObject == bean) {</span><br><span class="line">exposedObject = earlySingletonReference;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) {</span><br><span class="line">String[] dependentBeans = getDependentBeans(beanName);</span><br><span class="line">Set&lt;String&gt; actualDependentBeans = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(dependentBeans.length);</span><br><span class="line"><span class="keyword">for</span> (String dependentBean : dependentBeans) {</span><br><span class="line">            <span class="comment">// 检测依赖</span></span><br><span class="line"><span class="keyword">if</span> (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) {</span><br><span class="line">actualDependentBeans.add(dependentBean);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">          <span class="comment">// 因为bean创建后，其所依赖的bean一定是已经创建的，actualDependentBeans不为空则表示当前 bean创建后其依赖的bean却没有没全部创建完，也就是说存在循环依赖</span></span><br><span class="line"><span class="keyword">if</span> (!actualDependentBeans.isEmpty()) {</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName,</span><br><span class="line"><span class="string">"Bean with name '"</span> + beanName + <span class="string">"' has been injected into other beans ["</span> +</span><br><span class="line">StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +</span><br><span class="line"><span class="string">"] in its raw version as part of a circular reference, but has eventually been "</span> +</span><br><span class="line"><span class="string">"wrapped. This means that said other beans do not use the final version of the "</span> +</span><br><span class="line"><span class="string">"bean. This is often the result of over-eager type matching - consider using "</span> +</span><br><span class="line"><span class="string">"'getBeanNamesOfType' with the 'allowEagerInit' flag turned off, for example."</span>);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register bean as disposable.</span></span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line">      <span class="comment">// 根据scope注册DisposableBean</span></span><br><span class="line">registerDisposableBeanIfNecessary(beanName, bean, mbd);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">catch</span> (BeanDefinitionValidationException ex) {</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">mbd.getResourceDescription(), beanName, <span class="string">"Invalid destruction signature"</span>, ex);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> exposedObject;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><code>doCreateBean</code>是创建bean的地方。包括实例化bean、填充bean、调用一些初始化方法、循环依赖检测等。</p><h4 id="createBeanInstance"><a href="#createBeanInstance" class="headerlink" title="createBeanInstance"></a>createBeanInstance</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为指定的bean创建新的bean实例，其使用合适的实例化策略，比如工厂方法、构造器注入、或者简单实例化</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> BeanWrapper <span class="title">createBeanInstance</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span> </span>{</span><br><span class="line"><span class="comment">// 解析bean的Class</span></span><br><span class="line">Class&lt;?&gt; beanClass = resolveBeanClass(mbd, beanName);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (beanClass != <span class="keyword">null</span> &amp;&amp; !Modifier.isPublic(beanClass.getModifiers()) &amp;&amp; !mbd.isNonPublicAccessAllowed()) {</span><br><span class="line">      <span class="comment">// bean访问修饰符验证</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line"><span class="string">"Bean class isn't public, and non-public access not allowed: "</span> + beanClass.getName());</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">Supplier&lt;?&gt; instanceSupplier = mbd.getInstanceSupplier();</span><br><span class="line"><span class="keyword">if</span> (instanceSupplier != <span class="keyword">null</span>) {</span><br><span class="line">      <span class="comment">// 如果bean定义中提供了Supplier函数，则使用Supplier函数生成bean，然后包装成BeanWrapper</span></span><br><span class="line"><span class="keyword">return</span> obtainFromSupplier(instanceSupplier, beanName);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (mbd.getFactoryMethodName() != <span class="keyword">null</span>) {</span><br><span class="line">      <span class="comment">// 如果bean定义中提供了工厂方法，则使用工厂方法生成BeanWrapper</span></span><br><span class="line"><span class="keyword">return</span> instantiateUsingFactoryMethod(beanName, mbd, args);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 再次创建同样的bean，提供短路运算</span></span><br><span class="line"><span class="keyword">boolean</span> resolved = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">boolean</span> autowireNecessary = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">if</span> (args == <span class="keyword">null</span>) {</span><br><span class="line"><span class="keyword">synchronized</span> (mbd.constructorArgumentLock) {</span><br><span class="line">        <span class="comment">// 如果已经解析过构造方法</span></span><br><span class="line"><span class="keyword">if</span> (mbd.resolvedConstructorOrFactoryMethod != <span class="keyword">null</span>) {</span><br><span class="line">resolved = <span class="keyword">true</span>;</span><br><span class="line">autowireNecessary = mbd.constructorArgumentsResolved;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> (resolved) {</span><br><span class="line">      <span class="comment">// 到这里是短路</span></span><br><span class="line"><span class="keyword">if</span> (autowireNecessary) {</span><br><span class="line">        <span class="comment">// 如果构造函数已经解析，则使用已解析的构造函数</span></span><br><span class="line"><span class="keyword">return</span> autowireConstructor(beanName, mbd, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// 使用InstantiationStrategy选用DeclaredConstructor构造</span></span><br><span class="line"><span class="keyword">return</span> instantiateBean(beanName, mbd);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从SmartInstantiationAwareBeanPostProcessor解析候选的构造函数</span></span><br><span class="line">Constructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);</span><br><span class="line"><span class="keyword">if</span> (ctors != <span class="keyword">null</span> || mbd.getResolvedAutowireMode() == AUTOWIRE_CONSTRUCTOR ||</span><br><span class="line">mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args)) {</span><br><span class="line">      <span class="comment">// 使用构造函数自动注入</span></span><br><span class="line"><span class="keyword">return</span> autowireConstructor(beanName, mbd, ctors, args);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ctors = mbd.getPreferredConstructors();</span><br><span class="line"><span class="keyword">if</span> (ctors != <span class="keyword">null</span>) {</span><br><span class="line">      <span class="comment">// 使用偏好的构造函数注入（RootBeanDefinition中定义）</span></span><br><span class="line"><span class="keyword">return</span> autowireConstructor(beanName, mbd, ctors, <span class="keyword">null</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用默认的构造函数注入</span></span><br><span class="line"><span class="keyword">return</span> instantiateBean(beanName, mbd);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>此方法选用合适的策略来创建bean。可以看出优先使用<code>Supplier</code>，再是工厂方法，再是带参构造函数，最后才是无参构造函数。其具体的构造函数注入比较复杂，就不分析，其实就是根据参数的最大匹配来选择最合适的构造函数。</p><h4 id="getEarlyBeanReference"><a href="#getEarlyBeanReference" class="headerlink" title="getEarlyBeanReference"></a>getEarlyBeanReference</h4><p>此方法调用了<code>SmartInstantiationAwareBeanPostProcessor.getEarlyBeanReference</code>，查看实现类中有<code>AbstractAutoProxyCreator</code>，即我们熟知的aop，如果有增强那么这一步放入的将会是增强后的对象。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getEarlyBeanReference</span><span class="params">(String beanName, RootBeanDefinition mbd, Object bean)</span> </span>{</span><br><span class="line">Object exposedObject = bean;</span><br><span class="line"><span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) {</span><br><span class="line"><span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) {</span><br><span class="line"><span class="keyword">if</span> (bp <span class="keyword">instanceof</span> SmartInstantiationAwareBeanPostProcessor) {</span><br><span class="line">SmartInstantiationAwareBeanPostProcessor ibp = (SmartInstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">          <span class="comment">// 调用getEarlyBeanReference对早期对象进行处理</span></span><br><span class="line">exposedObject = ibp.getEarlyBeanReference(exposedObject, beanName);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> exposedObject;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h4 id="populateBean"><a href="#populateBean" class="headerlink" title="populateBean"></a>populateBean</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">populateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> BeanWrapper bw)</span> </span>{</span><br><span class="line">    <span class="comment">// BeanWrapper检查（查看调用处，未发现为null的情况）</span></span><br><span class="line"><span class="keyword">if</span> (bw == <span class="keyword">null</span>) {</span><br><span class="line"><span class="keyword">if</span> (mbd.hasPropertyValues()) {</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">mbd.getResourceDescription(), beanName, <span class="string">"Cannot apply property values to null instance"</span>);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> {</span><br><span class="line"><span class="comment">// Skip property population phase for null instance.</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Give any InstantiationAwareBeanPostProcessors the opportunity to modify the</span></span><br><span class="line"><span class="comment">// state of the bean before properties are set. This can be used, for example,</span></span><br><span class="line"><span class="comment">// to support styles of field injection.</span></span><br><span class="line"><span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) {</span><br><span class="line"><span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) {</span><br><span class="line"><span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) {</span><br><span class="line">InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line"><span class="keyword">if</span> (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) {</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">PropertyValues pvs = (mbd.hasPropertyValues() ? mbd.getPropertyValues() : <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> resolvedAutowireMode = mbd.getResolvedAutowireMode();</span><br><span class="line"><span class="keyword">if</span> (resolvedAutowireMode == AUTOWIRE_BY_NAME || resolvedAutowireMode == AUTOWIRE_BY_TYPE) {</span><br><span class="line">MutablePropertyValues newPvs = <span class="keyword">new</span> MutablePropertyValues(pvs);</span><br><span class="line"><span class="comment">// Add property values based on autowire by name if applicable.</span></span><br><span class="line"><span class="keyword">if</span> (resolvedAutowireMode == AUTOWIRE_BY_NAME) {</span><br><span class="line">autowireByName(beanName, mbd, bw, newPvs);</span><br><span class="line">}</span><br><span class="line"><span class="comment">// Add property values based on autowire by type if applicable.</span></span><br><span class="line"><span class="keyword">if</span> (resolvedAutowireMode == AUTOWIRE_BY_TYPE) {</span><br><span class="line">autowireByType(beanName, mbd, bw, newPvs);</span><br><span class="line">}</span><br><span class="line">pvs = newPvs;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors();</span><br><span class="line"><span class="keyword">boolean</span> needsDepCheck = (mbd.getDependencyCheck() != AbstractBeanDefinition.DEPENDENCY_CHECK_NONE);</span><br><span class="line"></span><br><span class="line">PropertyDescriptor[] filteredPds = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (hasInstAwareBpps) {</span><br><span class="line"><span class="keyword">if</span> (pvs == <span class="keyword">null</span>) {</span><br><span class="line">pvs = mbd.getPropertyValues();</span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) {</span><br><span class="line"><span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) {</span><br><span class="line">InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">PropertyValues pvsToUse = ibp.postProcessProperties(pvs, bw.getWrappedInstance(), beanName);</span><br><span class="line"><span class="keyword">if</span> (pvsToUse == <span class="keyword">null</span>) {</span><br><span class="line"><span class="keyword">if</span> (filteredPds == <span class="keyword">null</span>) {</span><br><span class="line">filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);</span><br><span class="line">}</span><br><span class="line">pvsToUse = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);</span><br><span class="line"><span class="keyword">if</span> (pvsToUse == <span class="keyword">null</span>) {</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">pvs = pvsToUse;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> (needsDepCheck) {</span><br><span class="line"><span class="keyword">if</span> (filteredPds == <span class="keyword">null</span>) {</span><br><span class="line">filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);</span><br><span class="line">}</span><br><span class="line">checkDependencies(beanName, mbd, filteredPds, pvs);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pvs != <span class="keyword">null</span>) {</span><br><span class="line">applyPropertyValues(beanName, mbd, bw, pvs);</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h4 id="initializeBean"><a href="#initializeBean" class="headerlink" title="initializeBean"></a>initializeBean</h4><p>此方法执行Bean创建过程的初始化流程，其顺序为：<code>Aware</code>-&gt;<code>postProcessBeforeInitialization</code>-&gt;<code>afterPropertiesSet</code>-&gt;<code>init-method</code>-&gt;<code>postProcessAfterInitialization</code></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">initializeBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> Object bean, <span class="meta">@Nullable</span> RootBeanDefinition mbd)</span> </span>{</span><br><span class="line"><span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) {</span><br><span class="line">AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; {</span><br><span class="line">invokeAwareMethods(beanName, bean);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">}, getAccessControlContext());</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// 调用Aware方法，包括BeanNameAware、BeanClassLoaderAware、BeanFactoryAware</span></span><br><span class="line">invokeAwareMethods(beanName, bean);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">Object wrappedBean = bean;</span><br><span class="line"><span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) {</span><br><span class="line">            <span class="comment">// 调用所有的BeanPostProcessor.postProcessBeforeInitialization方法</span></span><br><span class="line">wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">// 如果bean是InitializingBean，则调用afterPropertiesSet</span></span><br><span class="line">            <span class="comment">// 然后调用bean定义中的'init-method'</span></span><br><span class="line">invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) {</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">(mbd != <span class="keyword">null</span> ? mbd.getResourceDescription() : <span class="keyword">null</span>),</span><br><span class="line">beanName, <span class="string">"Invocation of init method failed"</span>, ex);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) {</span><br><span class="line">            <span class="comment">// 调用所有的BeanPostProcessor.postProcessAfterInitialization方法</span></span><br><span class="line">wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> wrappedBean;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><hr><h2 id="ListableBeanFactory"><a href="#ListableBeanFactory" class="headerlink" title="ListableBeanFactory"></a><code>ListableBeanFactory</code></h2><blockquote><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ListableBeanFactory</span> <span class="keyword">extends</span> <span class="title">BeanFactory</span></span></span><br></pre></td></tr></tbody></table></figure></div></blockquote><p>从命名来看，这个接口就是用来罗列满足某些条件的bean的。</p><h3 id="特性-3"><a href="#特性-3" class="headerlink" title="特性"></a>特性</h3><ul><li>查询bean定义只考虑当前工厂，不考虑父工厂，也不考虑手动注册的单例</li><li>通过<code>ResolvableType</code>查询，同样不考虑父工厂，会考虑各种类型的bean，包括<code>FactoryBean</code>、singleton和prototype</li><li>通过type查找，同上</li><li>还可以通过<code>Annotation</code>查找</li></ul><hr><h2 id="ConfigurableListableBeanFactory"><a href="#ConfigurableListableBeanFactory" class="headerlink" title="ConfigurableListableBeanFactory"></a><code>ConfigurableListableBeanFactory</code></h2><blockquote><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConfigurableListableBeanFactory</span></span></span><br><span class="line"><span class="class">      <span class="keyword">extends</span> <span class="title">ListableBeanFactory</span>, <span class="title">AutowireCapableBeanFactory</span>, <span class="title">ConfigurableBeanFactory</span></span></span><br></pre></td></tr></tbody></table></figure></div></blockquote><p>给大多数可罗列的bean工厂实现的配置接口。除了继承<code>ConfigurableBeanFactory</code>，还提供了分析和修改bean定义和提前实例化单例。此接口主要供框架内使用（<code>ApplicationContext</code>）。</p><hr><h2 id="BeanDefinitionRegistry"><a href="#BeanDefinitionRegistry" class="headerlink" title="BeanDefinitionRegistry"></a><code>BeanDefinitionRegistry</code></h2><blockquote><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanDefinitionRegistry</span> <span class="keyword">extends</span> <span class="title">AliasRegistry</span></span></span><br></pre></td></tr></tbody></table></figure></div></blockquote><p>注册bean definition的接口。</p><hr><h2 id="DefaultListableBeanFactory"><a href="#DefaultListableBeanFactory" class="headerlink" title="DefaultListableBeanFactory"></a><code>DefaultListableBeanFactory</code></h2><blockquote><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultListableBeanFactory</span> <span class="keyword">extends</span> <span class="title">AbstractAutowireCapableBeanFactory</span></span></span><br><span class="line"><span class="class">      <span class="keyword">implements</span> <span class="title">ConfigurableListableBeanFactory</span>, <span class="title">BeanDefinitionRegistry</span>, <span class="title">Serializable</span></span></span><br></pre></td></tr></tbody></table></figure></div></blockquote><p><code>ConfigurableListableBeanFactory</code>接口的默认实现。基本上已经是个成熟的bean工厂了，除了解析bean定义，已经具备了bean factory的所有能力了。其也是<code>ApplicationContext</code>体系中默认使用的工厂。</p><h3 id="特性-4"><a href="#特性-4" class="headerlink" title="特性"></a>特性</h3><ul><li>支持序列化</li><li>允许bean定义覆盖、允许提前加载bean的class</li><li>作为<code>BeanDefinition</code>的容器并记录注册顺序</li><li>记录依赖的Class type到bean name的映射关系</li><li>记录手动注册的singleton和其顺序</li><li>记录冻结的配置快照</li><li><strong>candidate查找的顺序是</strong>：先通过<code>getBeanNamesForType</code>查找所有候选者-&gt;如果只有一个则返回-&gt;bean定义中的primary属性(唯一)-&gt;<code>dependencyComparator</code>中第一的优先级(唯一)</li></ul><h3 id="重要方法-4"><a href="#重要方法-4" class="headerlink" title="重要方法"></a>重要方法</h3><h4 id="resolveBean"><a href="#resolveBean" class="headerlink" title="resolveBean"></a>resolveBean</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class&lt;T&gt; requiredType, <span class="meta">@Nullable</span> Object... args)</span> <span class="keyword">throws</span> BeansException </span>{</span><br><span class="line">Assert.notNull(requiredType, <span class="string">"Required type must not be null"</span>);</span><br><span class="line">    <span class="comment">// 'getBean'是用户常使用的方法，其内部调用的是'resolveBean'</span></span><br><span class="line">Object resolved = resolveBean(ResolvableType.forRawClass(requiredType), args, <span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">if</span> (resolved == <span class="keyword">null</span>) {</span><br><span class="line">            <span class="comment">// 若没有找到对应的bean，则抛出异常</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> NoSuchBeanDefinitionException(requiredType);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> (T) resolved;</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 下面是resolveBean的代码实现</span></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">T <span class="title">resolveBean</span><span class="params">(ResolvableType requiredType, <span class="meta">@Nullable</span> Object[] args, <span class="keyword">boolean</span> nonUniqueAsNull)</span> </span>{</span><br><span class="line">    <span class="comment">// 其又调用了'resovleNamedBean'</span></span><br><span class="line">    <span class="comment">// NamedBeanHolder是个简单的bean载体，只用beanName和bean实例</span></span><br><span class="line">NamedBeanHolder&lt;T&gt; namedBean = resolveNamedBean(requiredType, args, nonUniqueAsNull);</span><br><span class="line"><span class="keyword">if</span> (namedBean != <span class="keyword">null</span>) {</span><br><span class="line"><span class="keyword">return</span> namedBean.getBeanInstance();</span><br><span class="line">}</span><br><span class="line">    <span class="comment">// 若Local没有找到，则到父工厂中寻找</span></span><br><span class="line">BeanFactory parent = getParentBeanFactory();</span><br><span class="line"><span class="keyword">if</span> (parent <span class="keyword">instanceof</span> DefaultListableBeanFactory) {</span><br><span class="line">            <span class="comment">// 若父工厂也是'DefaultListableBeanFactory'，则使用其'resolveBean'的返回值</span></span><br><span class="line"><span class="keyword">return</span> ((DefaultListableBeanFactory) parent).resolveBean(requiredType, args, nonUniqueAsNull);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (parent != <span class="keyword">null</span>) {</span><br><span class="line">            <span class="comment">// 若父工厂不是'DefaultListableBeanFactory'，则使用‘ObjectProvider’获取bean</span></span><br><span class="line">ObjectProvider&lt;T&gt; parentProvider = parent.getBeanProvider(requiredType);</span><br><span class="line"><span class="keyword">if</span> (args != <span class="keyword">null</span>) {</span><br><span class="line"><span class="keyword">return</span> parentProvider.getObject(args);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> {</span><br><span class="line"><span class="keyword">return</span> (nonUniqueAsNull ? parentProvider.getIfUnique() : parentProvider.getIfAvailable());</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h4 id="resolveNamedBean"><a href="#resolveNamedBean" class="headerlink" title="resolveNamedBean"></a>resolveNamedBean</h4><p>我们知道，<code>resolveBean()</code>实际是委托给了<code>resolveNamedBean()</code>获取bean的。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">NamedBeanHolder&lt;T&gt; <span class="title">resolveNamedBean</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">ResolvableType requiredType, <span class="meta">@Nullable</span> Object[] args, <span class="keyword">boolean</span> nonUniqueAsNull)</span> <span class="keyword">throws</span> BeansException </span>{</span><br><span class="line"></span><br><span class="line">Assert.notNull(requiredType, <span class="string">"Required type must not be null"</span>);</span><br><span class="line">    <span class="comment">// 获取匹配指定类型的beanName，也就是候选者名称</span></span><br><span class="line">String[] candidateNames = getBeanNamesForType(requiredType);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (candidateNames.length &gt; <span class="number">1</span>) {</span><br><span class="line">            <span class="comment">// 如果候选者有多个，则要先进行筛选</span></span><br><span class="line">List&lt;String&gt; autowireCandidates = <span class="keyword">new</span> ArrayList&lt;&gt;(candidateNames.length);</span><br><span class="line"><span class="keyword">for</span> (String beanName : candidateNames) {</span><br><span class="line"><span class="keyword">if</span> (!containsBeanDefinition(beanName) || getBeanDefinition(beanName).isAutowireCandidate()) {</span><br><span class="line">                    <span class="comment">// 将BeanDefinition中'autowireCandidate'为false的过滤掉</span></span><br><span class="line">                    <span class="comment">// 这里的判断条件可能有些迷惑性，首先我们要明确bean的注册方式有BeanDefinition和</span></span><br><span class="line">                    <span class="comment">// 手动注册的方式，'!containsBeanDefinition(beanName)'为true说明是手动注册的</span></span><br><span class="line">                    <span class="comment">// 方式，当然是属于候选者</span></span><br><span class="line">autowireCandidates.add(beanName);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> (!autowireCandidates.isEmpty()) {</span><br><span class="line">                <span class="comment">// 这里可以反向思考一下，如果所有候选者都被过滤掉了，那么可以不用过滤</span></span><br><span class="line">candidateNames = StringUtils.toStringArray(autowireCandidates);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (candidateNames.length == <span class="number">1</span>) {</span><br><span class="line">            <span class="comment">// 候选者唯一，那么获取该bean即可</span></span><br><span class="line">String beanName = candidateNames[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> NamedBeanHolder&lt;&gt;(beanName, (T) getBean(beanName, requiredType.toClass(), args));</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (candidateNames.length &gt; <span class="number">1</span>) {</span><br><span class="line">            <span class="comment">// 候选者存在多个，则需要判断优先级，先构造一个Map</span></span><br><span class="line">            <span class="comment">// beanName-&gt;beanInstance或者beanName-&gt;beanClass</span></span><br><span class="line">Map&lt;String, Object&gt; candidates = <span class="keyword">new</span> LinkedHashMap&lt;&gt;(candidateNames.length);</span><br><span class="line"><span class="keyword">for</span> (String beanName : candidateNames) {</span><br><span class="line"><span class="keyword">if</span> (containsSingleton(beanName) &amp;&amp; args == <span class="keyword">null</span>) {</span><br><span class="line">Object beanInstance = getBean(beanName);</span><br><span class="line">candidates.put(beanName, (beanInstance <span class="keyword">instanceof</span> NullBean ? <span class="keyword">null</span> : beanInstance));</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> {</span><br><span class="line">candidates.put(beanName, getType(beanName));</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">            <span class="comment">// 获取具有'primary'属性的bean，注意两个或以上会抛异常</span></span><br><span class="line">String candidateName = determinePrimaryCandidate(candidates, requiredType.toClass());</span><br><span class="line"><span class="keyword">if</span> (candidateName == <span class="keyword">null</span>) {</span><br><span class="line">                <span class="comment">// 如果没有’primary‘的bean，则按照优选级排序(@Priority)，取具有最高优先级的bean，注意相同优先级的bean也不能有两个或以上</span></span><br><span class="line">candidateName = determineHighestPriorityCandidate(candidates, requiredType.toClass());</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> (candidateName != <span class="keyword">null</span>) {</span><br><span class="line">                <span class="comment">// 找到最匹配的候选者，获取bean实例后返回</span></span><br><span class="line">Object beanInstance = candidates.get(candidateName);</span><br><span class="line"><span class="keyword">if</span> (beanInstance == <span class="keyword">null</span> || beanInstance <span class="keyword">instanceof</span> Class) {</span><br><span class="line">beanInstance = getBean(candidateName, requiredType.toClass(), args);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> NamedBeanHolder&lt;&gt;(candidateName, (T) beanInstance);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> (!nonUniqueAsNull) {</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> NoUniqueBeanDefinitionException(requiredType, candidates.keySet());</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h4 id="preInstantiateSingletons"><a href="#preInstantiateSingletons" class="headerlink" title="preInstantiateSingletons"></a>preInstantiateSingletons</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preInstantiateSingletons</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>{</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) {</span><br><span class="line">logger.trace(<span class="string">"Pre-instantiating singletons in "</span> + <span class="keyword">this</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对'beanDefinitionNames'做一个快照，以允许注册新的beanDefinition</span></span><br><span class="line">List&lt;String&gt; beanNames = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.beanDefinitionNames);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化所有的非惰性的(non-lazy)单例bean</span></span><br><span class="line"><span class="keyword">for</span> (String beanName : beanNames) {</span><br><span class="line">      <span class="comment">// 获取RootBeanDifinition</span></span><br><span class="line">RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line"><span class="keyword">if</span> (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) {</span><br><span class="line">        <span class="comment">// 对于非抽象的、单例的、非惰性的bean</span></span><br><span class="line"><span class="keyword">if</span> (isFactoryBean(beanName)) {</span><br><span class="line">          <span class="comment">// 如果'beanName'是一个FactoryBean，则获取这个FactoryBean</span></span><br><span class="line">Object bean = getBean(FACTORY_BEAN_PREFIX + beanName);</span><br><span class="line">          <span class="comment">// 这里还需要再判断一下，因为有NullBean</span></span><br><span class="line"><span class="keyword">if</span> (bean <span class="keyword">instanceof</span> FactoryBean) {</span><br><span class="line"><span class="keyword">final</span> FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) bean;</span><br><span class="line"><span class="keyword">boolean</span> isEagerInit;</span><br><span class="line"><span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span> &amp;&amp; factory <span class="keyword">instanceof</span> SmartFactoryBean) {</span><br><span class="line">isEagerInit = AccessController.doPrivileged((PrivilegedAction&lt;Boolean&gt;)</span><br><span class="line">((SmartFactoryBean&lt;?&gt;) factory)::isEagerInit,</span><br><span class="line">getAccessControlContext());</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> {</span><br><span class="line">              <span class="comment">// 一般来说，FactoryBean的单例都是lazy-init的，然而如果是SmartFactoryBean，</span></span><br><span class="line">              <span class="comment">// 且设置了eager init，则需要提前初始化</span></span><br><span class="line">isEagerInit = (factory <span class="keyword">instanceof</span> SmartFactoryBean &amp;&amp;</span><br><span class="line">((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> (isEagerInit) {</span><br><span class="line">getBean(beanName);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> {</span><br><span class="line">                    <span class="comment">// 若不是FactoryBean，则需要初始化</span></span><br><span class="line">getBean(beanName);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发`SmartInitializingSingleton.afterSingletonsInstantiated`回调</span></span><br><span class="line"><span class="keyword">for</span> (String beanName : beanNames) {</span><br><span class="line">Object singletonInstance = getSingleton(beanName);</span><br><span class="line"><span class="keyword">if</span> (singletonInstance <span class="keyword">instanceof</span> SmartInitializingSingleton) {</span><br><span class="line"><span class="keyword">final</span> SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance;</span><br><span class="line"><span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) {</span><br><span class="line">AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; {</span><br><span class="line">smartSingleton.afterSingletonsInstantiated();</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">}, getAccessControlContext());</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> {</span><br><span class="line">smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
      
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nexus(Maven)仓库搭建和常见问题</title>
      <link href="/2020/03/30/nexus-repo/"/>
      <url>/2020/03/30/nexus-repo/</url>
      
        <content type="html"><![CDATA[<html><head><script src="\assets\js\APlayer.min.js"> </script></head><body><blockquote><p>Nexus仓库管理器可用于maven/docker/npm/pypi/yum等相关组件的储存和管理，本文使用Docker + Nexus 3搭建仓库，并应用于maven项目</p></blockquote><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>只想着搭建Nexus仓库的朋友可以直接略过某些地方，比如这里。</p><h3 id="组件-Components"><a href="#组件-Components" class="headerlink" title="组件(Components)"></a>组件(Components)</h3><p>Nexus作为的多种构建工具仓库的管理器，不同工具的操作的对象不用，而在Nexus里统一称为<strong>组件</strong>。组件由**坐标(coordinates)**唯一确定，包括group，name和version。以Maven为例：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">xml</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>fun.kidon<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> # 一般写开发团体</span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>my-project<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> # 项目的名字</span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.1-RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span> # 版本</span><br></pre></td></tr></tbody></table></figure></div><p>以上三条信息在Maven中是必须的，通过它们就可以确定唯一组件(dependency或plugin)了，其中groupId和artifactId决定唯一的具体项目。</p><h3 id="资产-Assets"><a href="#资产-Assets" class="headerlink" title="资产(Assets)"></a>资产(Assets)</h3><p>与组件相关联的资源或是说文件，比如JAR组件中含有POM和JAR文件，甚至还有JavaDoc和源码文件。注意，资产并不只能是某组件独占的，它可以被共享，比如docker镜像的层，不同的镜像可以共享复用储存层。</p><h3 id="仓库-Repositories"><a href="#仓库-Repositories" class="headerlink" title="仓库(Repositories)"></a>仓库(Repositories)</h3><p>将某一类型的组件聚集起来就是仓库了，当然根据构建工具的差异，仓库格式和使用上也是不尽相同。</p><h2 id="Nexus3安装"><a href="#Nexus3安装" class="headerlink" title="Nexus3安装"></a>Nexus3安装</h2><h3 id="硬件准备"><a href="#硬件准备" class="headerlink" title="硬件准备"></a>硬件准备</h3><ol><li>CPU:推荐个数8+，最好不少于4个</li><li>内存：jvm分配2703MB~4GB，宿主机8GB+</li><li>为了允许进行虚拟内存交换，未分配的主机内存的最小值应该不低于总物理RAM的1/3</li><li>最大堆+最大直接内存&lt;=主机的内存 * 2/3</li><li>磁盘：根据具体使用而定，推荐300GB+</li></ol><p>上面的是推荐配置，并不是硬性要求，当然你总不希望突然某天就全线飙红吧，更多配置要求参考 <a href="https://help.sonatype.com/repomanager3/system-requirements">https://help.sonatype.com/repomanager3/system-requirements</a></p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>这里使用docker安装</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">shell</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker search nexus</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker pull sonatype/nexus3<span class="comment"># 拉取nexus3镜像</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mkdir -p -m 776 /usr/<span class="built_in">local</span>/nexus3/nexus-data</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker run -d -p 8081:8081 --name nexus -v /usr/<span class="built_in">local</span>/nexus3/nexus-data:/nexus-data --restart=always -e NEXUS_CONTEXT=nexus sonatype/nexus3<span class="comment"># 运行容器，命名为nexus，如果容器运行在某些云平台加上--ulimit nofile=65536:65536</span></span> </span><br><span class="line"><span class="meta">$</span><span class="bash"> docker ps<span class="comment"># 查看是否启动成功</span></span></span><br></pre></td></tr></tbody></table></figure></div><p>如果一切顺利，那么在浏览器中输入ip:8081/nexus就可以看到Nexus的界面了。如果无法访问看看Nexus是否启动成功或检查下防火墙设置。</p><p>本文主要是使用Nexus作为Maven仓库，后续可能会扩展其他类型的仓库，比如docker registry、npm registry等。</p><h2 id="Maven仓库配置和管理"><a href="#Maven仓库配置和管理" class="headerlink" title="Maven仓库配置和管理"></a>Maven仓库配置和管理</h2><p>Maven repository支持<strong>Apache Maven</strong>, Apache Ant/Ivy, Eclipse Aether, <strong>Gradle</strong>等。</p><h3 id="了解私有仓库"><a href="#了解私有仓库" class="headerlink" title="了解私有仓库"></a>了解私有仓库</h3><p>要让私有仓库为你服务怎么也得知道它是如何工作的吧。先来看个图片：</p><a href="/img/loading.gif" data-fancybox="group" data-caption="undefined" class="fancybox"><img style="zoom:70%" data-src="https://i.loli.net/2020/03/25/4h8P1zNgXWpoJcG.png" src="/img/loading.gif" class="lazyload"></a><p>这张图有几个简单的概念：本地仓库、私服、中央库。简单说本地仓库是你PC的某个目录；私服就是这里搭建的Nexus仓库；中央库是远程仓库之一。</p><p>我们会在Nexus仓库里面设置一些远程仓库的代理。查找依赖的流程是：如果本地仓库没有，则到私服寻找，如果私服也没有，它会到它代理的远程仓库里寻找（按照从上到下的优先级），找到后会在私服上储存一份，然后再下载到本地仓库。</p><p>而实际Maven的工作流程比这个可能要复杂，这个要看你具体的配置和使用了。</p><h3 id="Nexus上Maven仓库的配置-1"><a href="#Nexus上Maven仓库的配置-1" class="headerlink" title="Nexus上Maven仓库的配置^1"></a>Nexus上Maven仓库的配置<a href="https://help.sonatype.com/repomanager3/formats/maven-repositories">^1</a></h3><p>用admin的账号登录之后，可以看到齿轮型的管理者按钮，点击它，出现的就是你能配置的所有东西了。</p><h4 id="仓库类型"><a href="#仓库类型" class="headerlink" title="仓库类型"></a>仓库类型</h4><a href="/img/loading.gif" data-fancybox="group" data-caption="undefined" class="fancybox"><img sytle="zoom:70%" data-src="https://i.loli.net/2020/03/25/8IjU5YoZxVD4lpt.png" src="/img/loading.gif" class="lazyload"></a><p>可以看到仓库这一栏，Nexus默认为你配置了几个仓库，如果你感觉没用的可以删除。这里解释下仓库的类型：</p><ul><li>proxy:所代理的远程仓库，上面有介绍。</li><li>hosted:就是安装Nexus的宿主机上的仓库，类型有Release/Snapshot/Mixed，以后你上传的组件就放在hosted类型的仓库中，外部无法获取</li><li>group:可以包含其它仓库或者仓库组，通过一个url统一对外服务</li></ul><h4 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h4><p>点击上图那个创建仓库的按钮，我们创建一个代理仓库：<a href="/img/loading.gif" data-fancybox="group" data-caption="undefined" class="fancybox"><img style="zoom:70%" data-src="https://i.loli.net/2020/03/26/NPmLEae4blByOtX.png" src="/img/loading.gif" class="lazyload"></a></p><p>填入代理仓库三个主要的信息，还有其他的配置看说明即可明白，一般采用默认值即可：</p><a href="/img/loading.gif" data-fancybox="group" data-caption="undefined" class="fancybox"><img style="zoom:70%" data-src="https://i.loli.net/2020/03/26/mRzdXh3F4xLsiUS.png" src="/img/loading.gif" class="lazyload"></a><p>点击最下方的创建按钮，即完成仓库的创建。</p><p>回到仓库页面，点击仓库组，即那个maven-public，然后把阿里云的maven代理移动到右边，并且往上移动，保存离开。<strong>依赖查询的顺序是根据从上到下的顺序进行的</strong>：</p><a href="/img/loading.gif" data-fancybox="group" data-caption="undefined" class="fancybox"><img style="zoom:70%" data-src="https://i.loli.net/2020/03/26/NeLDRV3Aqpbnxsd.png" src="/img/loading.gif" class="lazyload"></a><p>稍后我会介绍如何在Maven项目中使用此私服仓库。</p><h3 id="常用Maven仓库"><a href="#常用Maven仓库" class="headerlink" title="常用Maven仓库"></a>常用Maven仓库</h3><table><thead><tr><th>仓库</th><th>url</th></tr></thead><tbody><tr><td>阿里云</td><td><a href="http://maven.aliyun.com/nexus/content/groups/public/">http://maven.aliyun.com/nexus/content/groups/public/</a></td></tr><tr><td>apache</td><td><a href="http://repo.maven.apache.org/maven2">http://repo.maven.apache.org/maven2</a></td></tr><tr><td>camunda</td><td><a href="https://app.camunda.com/nexus/content/groups/public">https://app.camunda.com/nexus/content/groups/public</a></td></tr><tr><td>spring.io</td><td><a href="http://repo.spring.io/release/">http://repo.spring.io/release/</a></td></tr><tr><td>ibiblio</td><td><a href="http://www.ibiblio.org/maven2">http://www.ibiblio.org/maven2</a></td></tr><tr><td>jboss</td><td><a href="http://repository.jboss.com/maven2/">http://repository.jboss.com/maven2/</a></td></tr></tbody></table><p>其实，国内maven镜像虽然快，但是更新比较慢，国外的仓库由于国内网络的原因，下载简直不能忍，但是更新很快，可以根据自身的情况选择，有些人会花些钱开代理访问外网比较快，建议使用原装。</p><h3 id="浏览和查询"><a href="#浏览和查询" class="headerlink" title="浏览和查询"></a>浏览和查询</h3><p>这里写这个主要是想表明Nexus确实给我们提供了很方便的查询组件信息的方法，以后你开发的组件在这都可以看到。如果你仓库里还没有组件，那么接着往下小节看吧。</p><p>在这个页面主要是供用户浏览、查询或者上传组件，你可以在这页尽情探索：</p><a href="/img/loading.gif" data-fancybox="group" data-caption="undefined" class="fancybox"><img style="zoom:70%" data-src="https://i.loli.net/2020/03/25/SAKYQfp4JecXodu.png" src="/img/loading.gif" class="lazyload"></a><p>可以看见组件所具有的资产(assets)和他们的信息及使用方法：</p><a href="/img/loading.gif" data-fancybox="group" data-caption="undefined" class="fancybox"><img style="zoom:70%" data-src="https://i.loli.net/2020/03/25/d2BscCYvRfLM7ol.png" src="/img/loading.gif" class="lazyload"></a><p>如果通过restful api设置了tag也能看见：</p><a href="/img/loading.gif" data-fancybox="group" data-caption="undefined" class="fancybox"><img style="zoom:70%" data-src="https://i.loli.net/2020/03/25/DR35OeJmiyLQV7g.png" src="/img/loading.gif" class="lazyload"></a><h3 id="清理策略-cleanup-policy"><a href="#清理策略-cleanup-policy" class="headerlink" title="清理策略(cleanup policy)"></a>清理策略(cleanup policy)</h3><p>最好是能设置自己的组件清理策略，以免不再使用的组件占据磁盘空间进而引发问题。<a href="https://help.sonatype.com/repomanager3/cleanup-policies">戳我查看清理策略</a>。</p><h2 id="Maven项目里使用私有仓库"><a href="#Maven项目里使用私有仓库" class="headerlink" title="Maven项目里使用私有仓库"></a>Maven项目里使用私有仓库</h2><p>在项目中配置Maven仓库，主要有两种方式：一种是在Maven的<code>settings.xml</code>里配置（全局或用户级），这样每个项目都能共享此配置；一种是在每个项目里的<code>pom.xml</code>中单独配置。这里在settings.xml里配置：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">xml</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">settings</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/SETTINGS/1.0.0"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">localRepository</span>&gt;</span>D:\repository<span class="tag">&lt;/<span class="name">localRepository</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">servers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">server</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">username</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">password</span>&gt;</span>admin123<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servers</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">mirrors</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>aliyun-maven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">mirrors</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">  <span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">profile</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>env-dev<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://192.168.204.128:8081/nexus/repository/maven-public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">updatePolicy</span>&gt;</span>always<span class="tag">&lt;/<span class="name">updatePolicy</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">pluginRepositories</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://192.168.204.128:8081/nexus/repository/maven-public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">releases</span>&gt;</span><span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span><span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span><span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span><span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">pluginRepositories</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--make the profile active all the time --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">activeProfiles</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">activeProfile</span>&gt;</span>env-dev<span class="tag">&lt;/<span class="name">activeProfile</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">activeProfiles</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></div><p><code>settings.xml</code>里每一项都都有简略的英文注释，不太多，可以好好看看。这里解释其中的几个：</p><ul><li><code>&lt;server/&gt;</code> 是提供给你的私服的认证信息的，这个在发布的时候需要使用，我们下面发布的时候会提到。注意，认证信息这里我们由于省事写了admin的账号，但是最好能分配一个开发者账号，Nexus提供了丰富的账号权限管理能力。</li><li><code>&lt;mirrors/&gt;</code> 简单说来就是某个远程仓库的镜像，这里其实可以不用写这配置，不过为了说明还是列出来了。<strong>注意:镜像的工作方式类似于拦截器，当远程仓库被镜像匹配到的(<code>&lt;mirrorOf/&gt;</code>)，请求被重定向到镜像仓库，获取 jar 包将从镜像仓库获取，而不是我们配置的repository仓库，repository将失去作用</strong>。</li><li><code>&lt;profiles/&gt;</code> 在这里我们可以为不同环境定制构建方式，我们的私有仓库就配置在这里，其中的仓库的<code>&lt;url/&gt;</code>就是Nexus的仓库组，还说明了此仓库用于release和snapshot版本。它的激活方式也是十分丰富，这里只用了其中一种，建议好好了解关于此配置项的内容，在多环境、CI/CD中会有作用。</li></ul><p>以上配置完成，清理你本地仓库里的组件，重新导入一次依赖，就能看见依赖都是从私有仓库导入的了，同时登陆私有仓库，也能在上面看见仓库里缓存了这些组件。下载完成，该说说上传了。</p><h3 id="项目发布至仓库"><a href="#项目发布至仓库" class="headerlink" title="项目发布至仓库"></a>项目发布至仓库</h3><p>在项目的<code>pom.xml</code>中加入发布和快照仓库的信息：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">xml</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">distributionManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">name</span>&gt;</span>Releases<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://192.168.204.128:8081/nexus/repository/maven-releases/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">snapshotRepository</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">name</span>&gt;</span>Snapshot<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://192.168.204.128:8081/nexus/repository/maven-snapshots/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">snapshotRepository</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">distributionManagement</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure></div><p>这里的neuxs作为id，同<code>settings.xml</code>里的<code>&lt;server/&gt;</code>id要一致，用户信息只能放在<code>settings.xml</code>中，用于提供认证。在Maven的deploy阶段，就能把项目发布到对应的仓库了。</p><p>执行<code>mvn clean deploy</code>，再到仓库里看看，我们的快照版本确实发布到了快照仓库了，这样你小伙伴的其他的项目就能通过坐标引用这个组件了：</p><a href="/img/loading.gif" data-fancybox="group" data-caption="undefined" class="fancybox"><img style="zoom:70%" data-src="https://i.loli.net/2020/03/30/fk6DHuKb5GOUF3J.png" src="/img/loading.gif" class="lazyload"></a><p>那接下来简单说说Maven的发布和快照版本。</p><h3 id="Maven的Release版本与Snapshot版本"><a href="#Maven的Release版本与Snapshot版本" class="headerlink" title="Maven的Release版本与Snapshot版本"></a>Maven的Release版本与Snapshot版本</h3><ul><li><p>Release（发布）代表可靠、稳定、不再改变的版本</p></li><li><p>Snapshot（快照）代表不稳定、尚处于开发中、随时可变的版本。</p></li></ul><p>区分快照版本和发布版本只要看是否以<code>-SNAPSHOT</code>为结尾，注意这里要全大写。</p><p>由于发布和快照版本的特性，在我们的POM文件中，如果某依赖项是发布版本，若本地仓库已有就不会再去远程仓库下载；而如果是快照版本，那么即使本地仓库已有该版本，也会下载远程仓库里的来更新本地的。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>Maven仓库实际上储存的文件是没有限制的，你可以储存WAR、JAR、源码、Ruby libraries等。Maven仓库中组件通过POM阐述。当Maven下载一个组件(dependency or plugin)时，对应组件的POM文件也会被下载，所有记录在此POM的组件也将被下载，如此反复，直到下载完所有依赖的组件。</p><p>有个小技巧，Maven是通过url使用http来下载的，比如从仓库下载fun.kidon开发的my-project项目的1.2.1-RELEASE版本那么url为：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">shell</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.../fun/kidon/my-project/1.2.1-RELEASE.jar</span><br></pre></td></tr></tbody></table></figure></div><p>同时POM文件也会被下载下来：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">shell</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.../fun/kidon/my-project/1.2.1-RELEASE.pom</span><br></pre></td></tr></tbody></table></figure></div><h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q &amp; A"></a>Q &amp; A</h2><ol><li><p>centos8中docker容器内dns无法工作？</p><p>这个是firewalld的问题，启用ip地址伪装就可以正常工作：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">shell</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> firewall-cmd --zone=public --add-masquerade --permanent</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> firewall-cmd --reload</span></span><br></pre></td></tr></tbody></table></figure></div><p>更多的firewalld设置可以查看<a href="/2020/03/10/firewalld/">这里</a>。</p></li></ol><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>Nexus仓库确实提供了很多丰富强大的功能，有很多这里并未涉及，比如restful api、定时任务、权限管理等。我们创建了Maven仓库并在项目中使用了它。除了组件管理，在未来Nexus仓库结合构建工具(Apache Maven等)可作为CI/CD中重要的一环参与生产实践，到时候就能扩大其价值了。之后应该还会涉及几个议题。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://help.sonatype.com/repomanager3">https://help.sonatype.com/repomanager3</a></p><p><a href="http://maven.apache.org/guides/mini/guide-mirror-settings.html">http://maven.apache.org/guides/mini/guide-mirror-settings.html</a></p><p><a href="https://www.xncoding.com/2017/09/02/tool/nexus.html">https://www.xncoding.com/2017/09/02/tool/nexus.html</a></p><p><a href="https://www.javatt.com/p/87942">https://www.javatt.com/p/87942</a></p><p><a href="https://www.jianshu.com/p/94b060e016a2">https://www.jianshu.com/p/94b060e016a2</a></p><p><a href="https://swenfang.github.io/2018/06/03/Maven-Priority/">https://swenfang.github.io/2018/06/03/Maven-Priority/</a></p></body></html>]]></content>
      
      
      
        <tags>
            
            <tag> maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS 8防火墙firewalld配置、管理与实践</title>
      <link href="/2020/03/10/firewalld/"/>
      <url>/2020/03/10/firewalld/</url>
      
        <content type="html"><![CDATA[<html><head><script src="\assets\js\APlayer.min.js"> </script></head><body><blockquote><p>前言： 最近用docker在新机器（CentOS 8）上运行容器，但是外部的访问进不来，容器内的dns解析也无法工作。</p></blockquote><p><em>在本文中，将展示如何为您的CentOS 8设置防火墙，并在<code>firewall-cmd</code>管理工具的帮助下进行管理。</em></p><h2 id="防火墙firewalld"><a href="#防火墙firewalld" class="headerlink" title="防火墙firewalld"></a>防火墙<code>firewalld</code></h2><p><strong>防火墙</strong>是被用于从不信任的流量中保护工作站或者服务器的机制，它通过定义一组安全规则来工作，这些安全规则确定是允许还是阻止特定流量，正确配置的防火墙是整个系统安全的最重要方面之一，**CentOS 8提供了一个动态的、可定制的、基于主机的、带有D-Bus接口的防火墙——<code>firewalld</code>**。在CentOS 8中，<code>nftables</code>取代<code>iptables</code>成为默认的Linux网络包过滤框架，中间采取daemon动态管理防火墙，管理工具是<code>firewalld</code>。也就是说，<code>firewalld</code>只是一个前端管理工具，它负责配置规则，真正起作用的是后面的过滤框架。</p><a href="/img/loading.gif" data-fancybox="group" data-caption="undefined" class="fancybox"><img style="zoom:70%" data-src="https://i.loli.net/2020/03/10/6Si5vcJ7Anpqwjg.png" src="/img/loading.gif" class="lazyload"></a><p><code>firewalld</code>其实在CentOS 7中就已经存在，可能大多数人更习惯于<code>iptables</code>。<code>iptables</code>里默认是每个服务是允许，需要拒绝的才去限制。而与<code>iptables</code>相反，**<code>firewalld</code>默认是拒绝**，需要放行的服务需要去设置。<code>firewalld</code>和<code>iptables</code>还有很多区别，这里不展开说来，有兴趣的同学请戳☞<a href="https://firewalld.org/">firewalld官网</a>或者自行去了解。</p><p>要配置防火墙，<strong>你必须以root或者具有<code>sudo</code>权限的用户的身份登录</strong>。<code>firewalld</code>可以通过<code>firewall-cmd</code>命令行工具和图形化工具<code>firewll-config</code>等来配置和管理，本文均采用命令行的方式叙述。</p><p>首先确定<code>firewalld</code>是运行着：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">shell</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> firewall-cmd --state <span class="comment"># firewalld的状态，启动为`running`，未启动为`not running`</span></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果发现firewall基于某些原因没有安装或者启动:</span></span><br><span class="line">yum install firewalld firewall-config # 安装firewalld，其中firewall-config是图形界面，可以选择不安装</span><br><span class="line">systemctl start  firewalld # 启动</span><br><span class="line">systemctl stop firewalld  # 停止</span><br><span class="line">systemctl enable firewalld # 启用自动启动</span><br><span class="line">systemctl disable firewalld # 禁用自动启动</span><br><span class="line">systemctl status firewalld # 或者 firewall-cmd --state 查看状态</span><br></pre></td></tr></tbody></table></figure></div><p>接下来介绍<code>firewalld</code>的基本概念和操作。</p><hr><h2 id="认识firewalld"><a href="#认识firewalld" class="headerlink" title="认识firewalld"></a>认识<code>firewalld</code></h2><p><code>firewalld</code>使用<strong>区域</strong>和<strong>服务</strong>的概念。基于区域和服务，能够允许或阻止进入或流出系统的网络流量。</p><h3 id="区域-zone"><a href="#区域-zone" class="headerlink" title="区域(zone)"></a>区域(zone)</h3><p>区域是预定义的规则集，指定您的计算机所连接的网络的信任级别。<strong>可以将网卡接口(Interfaces)和源地址(Sources)分配到区域，这也是激活区域的方法。</strong></p><p>可以通过以下命令来查看所有的区域：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">shell</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> firewall-cmd --get-zones</span></span><br><span class="line"><span class="meta">#</span><span class="bash">或者</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls -l /usr/lib/firewalld/zones/</span></span><br></pre></td></tr></tbody></table></figure></div><p>下面是<code>firewalld</code>提供的区域，它们根据区域的信任级别从不可信到可信排序：</p><table><thead><tr><th>区域</th><th align="left">描述</th></tr></thead><tbody><tr><td><strong>drop</strong></td><td align="left">任何传入的网络连接都被丢弃，并且没有任何通知（发送方无法感知）。仅能有发送出去的网络连接。</td></tr><tr><td><strong>block</strong></td><td align="left">任何接收的网络连接都被 IPv4 的 <code>icmp-host-prohibited</code> 信息和 IPv6 的 <code>icmp6-adm-prohibited</code> 信息所拒绝（发送方可感知），即拒绝所有网络连接，但是您可以允许选定的传入连接。</td></tr><tr><td><strong>public</strong></td><td align="left">供不受信任的公众地方使用。仅接受ssh或dhcpv6-client等服务连接（仅仅接收经过选择的连接）。<strong>这个也是默认设置的区域</strong>。</td></tr><tr><td><strong>external</strong></td><td align="left">用于在系统充当网关或路由器时并启用了NAT伪装的外部网络，出去的ipv4网络连接通过此区域伪装和转发，仅仅接收经过选择的连接。</td></tr><tr><td><strong>internal</strong></td><td align="left">用于在系统充当网关或路由器时的内部网络。网络上的其他系统通常是受信任的。仅允许选择的传入连接。</td></tr><tr><td><strong>dmz</strong></td><td align="left">经典的非军事区(DMZ)区域，提供对LAN的有限访问，仅接受ssh服务接连（仅仅接收经过选择的连接）。</td></tr><tr><td><strong>work</strong></td><td align="left">用于工作机器。网络上的其他计算机通常是可信的。仅接受ssh、ipp-client或dhcpv6-client服务连接 （仅仅接收经过选择的连接）。</td></tr><tr><td><strong>home</strong></td><td align="left">用于家用机器。网络上的其他计算机通常是可信的。仅接受ssh、mdns、ipp-client、samba-client、或dhcpv6-client服务连接（仅仅接收经过选择的连接）。</td></tr><tr><td><strong>trusted</strong></td><td align="left">接受所有网络连接。信任网络中的所有计算机。</td></tr></tbody></table><p>需要注意的是，block会明确拒绝掉数据包，而drop会选择丢弃掉数据包。因此，drop比较节省服务器资源；block会回应，比较占用资源。区域的规则不是固定的，用户可以根据自身的需求定制。</p><h3 id="服务-service"><a href="#服务-service" class="headerlink" title="服务(service)"></a>服务(service)</h3><p>服务只是本地端口、协议、源端口、目的地和防火墙帮助模块的列表，例如：</p><ul><li>Port – 443 or 25 or 110</li><li>Service – SSH, HTTP</li><li>Protocols – ICMP</li></ul><p>除了以上两个基本概念还有一些其他的配置项要注意：</p><h3 id="运行时和永久设置"><a href="#运行时和永久设置" class="headerlink" title="运行时和永久设置"></a>运行时和永久设置</h3><p><code>firewalld</code>使用两个独立的配置集，即运行时配置和永久配置。</p><p>运行时配置是实际运行的配置，在重新启动后不再生效。当<code>firewalld</code>守护进程启动时，它将加载永久配置，该配置将成为运行时配置。</p><p>在<code>firewalld-cmd</code>执行的命令中，如果是规则相关的，加上<code>--permanent</code>参数不会立即生效，只会被记录到配置文件。如果要生效需要调用<code>firewall-cmd --reload</code>重新加载；如果不加<code>--permanent</code>则是立即生效，但如果重新加载会被清掉。</p><p>此外，在<code>firewall-cmd</code>命令中有些命令需要必须加<code>--permanent</code>参数，比如<code>--set-target</code>。</p><p>要在两个配置集中应用更改，您可以使用以下两种方法之一:</p><ol><li>更改运行时配置并使其永久:</li></ol><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">shell</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> firewall-cmd &lt;options&gt;</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> firewall-cmd --runtime-to-permanent <span class="comment"># 将之前做的更改永久化</span></span></span><br></pre></td></tr></tbody></table></figure></div><ol start="2"><li>更改永久配置并重新加载<code>firewalld</code>守护进程:</li></ol><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">shell</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> firewall-cmd --permanent &lt;options&gt;</span> </span><br><span class="line"><span class="meta">$</span><span class="bash"> firewall-cmd --reload <span class="comment"># 永久配置重启生效</span></span></span><br></pre></td></tr></tbody></table></figure></div><h3 id="区域里包含的基本信息"><a href="#区域里包含的基本信息" class="headerlink" title="区域里包含的基本信息"></a>区域里包含的基本信息</h3><p>当查询某区域的信息时：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">shell</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> firewall-cmd --zone=work --list-all</span></span><br></pre></td></tr></tbody></table></figure></div><p>输出信息：</p><a href="/img/loading.gif" data-fancybox="group" data-caption="undefined" class="fancybox"><img style="zoom:90%" data-src="https://i.loli.net/2020/03/09/zvYksrayhmc1Q56.png" src="/img/loading.gif" class="lazyload"></a><ul><li><code>target:default</code> 区域放行策略。它决定了与该区域匹配，但是没有由这里的设置中显式处理的数据包的动作，可结合<a href="#jump">匹配的优先级</a>来理解。它有四个值：<ul><li><code>ACCEPT</code>：通过这个包。</li><li><code>%%REJECT%%</code>：拒绝这个包，并返回一个拒绝的回复。</li><li><code>DROP</code>：丢弃这个包，不回复任何信息。</li><li><code>default</code>：不做任何事情。该区域不再管它，把它踢到“楼上”。</li></ul></li><li><code>icmp-block-inversion</code> 这个是一个禁ping的参数，默认关闭</li><li><code>work (active)</code> active表示该区域是活动的，因为，它至少有一个接口或源分配给它。再次注意，<strong>将网卡接口和源分配到区域上将激活区域。</strong></li><li><code>interfaces: docker0</code> （网卡接口）是系统中的硬件和虚拟的网络适配器的名字，所有的活动的接口都将被分配到区域，要么是默认的区域，要么是用户指定的一个区域。但是，<strong>一个接口不能被分配给多于一个的区域</strong>。</li><li><code>sources:</code> 列出了分配到这个区域的源，可以是ip地址也可以是ip地址段。<strong>一个源（或重叠的源）不能被分配到多个区域</strong>。这样做的结果是产生一个未定义的行为，因为不清楚应该将哪些规则应用于该源。</li><li><code>services: dockpit dhcpv6-client ssh</code> 列出了允许通过这个防火墙的服务。你可以通过运行 <code>firewall-cmd --get-services</code> 得到一个防火墙预定义服务的详细列表。</li><li><code>ports:</code> 列出了一个允许通过这个防火墙的目标端口。它是用于你需要去允许一个没有在 <code>firewalld</code> 中定义的服务的情况下。</li><li><code>protocal</code>当前 Zone 开启的协议。通过 <code>/etc/protocols</code> 可以查看，常用的协议包括 <code>tcp</code>, <code>udp</code>等。</li><li><code>masquerade: no</code> 表示这个区域是否允许 IP 伪装。如果允许，它将允许 IP 转发，它可以让你的计算机作为一个路由器。</li><li><code>forward-ports:</code> 列出转发的端口。</li><li><code>icmp-blocks:</code> 可添加ICMP类型，当<code>icmp-block-inversion</code>为no时，这些ICMP类型被拒绝；当<code>icmp-block-inversion</code>为yes时，这些ICMP类型被允许。</li><li><code>rich rules:</code> 富规则，即更细致、更详细的防火墙规则策略，它的优先级在所有的防火墙策略中也是最高的。</li></ul><h3 id="匹配的优先级（包处理流程）"><a href="#匹配的优先级（包处理流程）" class="headerlink" title="匹配的优先级（包处理流程）"></a><span id="jump">匹配的优先级（包处理流程）</span></h3><p>因为指定一个源不是必需的，任何包都可以通过接口匹配而归属于一个区域，而不需要通过源匹配来归属一个区域。活动区域中扮演两个不同的角色。关联接口行为的区域作为接口区域，并且，关联源行为的区域作为源区域（一个区域能够扮演两个角色）。<code>firewalld</code> 按下列顺序处理一个包：</p><ol><li>如果匹配到 source 的 Zone（可以存在零个或一个这样的区域）。如果这个包满足一个<strong>富规则rich rule、服务是白名单中的、target 不是 default</strong>，那么源区域处理这个包，并且在这里结束。否则，向上传递这个包。</li><li>如果匹配到 interface 的 Zone（肯定有一个这样的区域）。如果该Zone能处理这个包，那么到这里结束。否则，向上传递这个包。</li><li>若网络接口未关联到特定的区域，则使用默认区域并执行该区域所指定的规则。</li></ol><p>这里的关键信息是，源区域优先于接口区域。因此，一般多区域的设计模式是：先创建一个 source Zone 允许特殊 IP 地址访问系统服务，再通过 interface Zone 来对其他的访问做限制。</p><p>包处理流程的例子：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">shell</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> firewall-cmd --zone=home --add-source=192.168.1.1/24</span></span><br></pre></td></tr></tbody></table></figure></div><p>当IP为 <code>192.168.1.2</code> 的数据包访问 <code>http</code> 服务时，将会首先匹配到 home Zone，<code>firewall-cmd --zone=home --list-all</code> 查看发现 <code>http</code> 服务没有开启，target 为 default，所以会被丢到上一层；这里假设 <code>192.168.1.1</code> 属于 <code>enp0s8</code> 网卡，那么将会匹配到 drop Zone，target 为 DROP，所以会将包直接丢弃。</p><h2 id="在firewalld上的操作"><a href="#在firewalld上的操作" class="headerlink" title="在firewalld上的操作"></a>在<code>firewalld</code>上的操作</h2><hr><h3 id="默认的zone"><a href="#默认的zone" class="headerlink" title="默认的zone"></a>默认的zone</h3><p>所谓默认的zone，就是在你没有使用<code> --zone</code>参数指定zone时，所有操作默认使用的zone，<strong>同时也在包处理流程中的默认zone</strong>。</p><p>获取默认的zone:</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">shell</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> firewall-cmd --get-default-zone <span class="comment"># 如果没做过配置，默认的应该为public</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> firewall-cmd --get-active-zones <span class="comment"># 查看活动中的zone</span></span></span><br></pre></td></tr></tbody></table></figure></div><p>当向<code>NetworkManager</code>添加新接口连接(例如eth0或ens3)时，它们被附加到默认的zone。查看网卡接口：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">shell</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ip link show</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 或者</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> nmcli device status</span></span><br></pre></td></tr></tbody></table></figure></div><p>改变默认的zone:</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">shell</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> firewall-cmd --set-default-zone=[zone]</span></span><br></pre></td></tr></tbody></table></figure></div><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><h4 id="查看具体zone的信息"><a href="#查看具体zone的信息" class="headerlink" title="查看具体zone的信息"></a>查看具体zone的信息</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">shell</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> firewall-cmd --zone=[zone] --list-all <span class="comment"># 下面是命令输出，对于每一项都可以单独设置</span></span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>活动中的zone</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">shell</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> firewall-cmd --get-active-zones <span class="comment"># 这个命令会返回所有绑定了source、interface以及默认的zone，并会说明在什么情况下使用。</span></span></span><br></pre></td></tr></tbody></table></figure></div><p><strong>查看所有zone的信息</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">shell</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> firewall-cmd --list-all-zones <span class="comment"># 查看所有zone的详细信息，这是个很长的列表</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> firewall-cmd --get-zones <span class="comment"># 查看可用的zone</span></span></span><br></pre></td></tr></tbody></table></figure></div><h4 id="设置zone上的规则"><a href="#设置zone上的规则" class="headerlink" title="设置zone上的规则"></a>设置zone上的规则</h4><h5 id="目标设置-target"><a href="#目标设置-target" class="headerlink" title="目标设置(target)"></a>目标设置(target)</h5><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">shell</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> firewall-cmd --permanent --get-target <span class="comment"># 这里的 --permanent 不能省略</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> firewall-cmd --permanent --set-target=[target] <span class="comment"># 值有default,ACCEPT,REJECT和DROP，这里的 --permanent 不能省略</span></span></span><br></pre></td></tr></tbody></table></figure></div><h5 id="端口设置-ports"><a href="#端口设置-ports" class="headerlink" title="端口设置(ports)"></a>端口设置(ports)</h5><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">shell</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> firewall-cmd --zone=[zone] --add-port=8080/tcp <span class="comment"># 放行tcp访问的8080端口,协议有tcp/udp/sctp/dccp</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> firewall-cmd --zone=[zone] --add-port=8080-9090/tcp <span class="comment"># 一串端口</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> firewall-cmd --zone=[zone] --list-ports <span class="comment"># 查看端口</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> firewall-cmd --zone=[zone] --query-port=8080/tcp <span class="comment"># 查看指定zone的指定端口</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> firewall-cmd --zone=[zone] --remove-port=8080/tcp <span class="comment"># 移除端口</span></span></span><br></pre></td></tr></tbody></table></figure></div><h5 id="源设置-sources"><a href="#源设置-sources" class="headerlink" title="源设置(sources)"></a>源设置(sources)</h5><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">shell</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> firewall-cmd --zone=[zone] --add-source=192.168.1.10/24 <span class="comment"># 绑定源到区域</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> firewall-cmd --zone=[zone] --list-sources <span class="comment"># 查看区域所绑定源的列表</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> firewall-cmd  --zone=[zone] --query-source=192.168.1.10/24 <span class="comment"># 查看指定zone是否和指定源绑定</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> firewall-cmd --get-zone-of-source=192.168.1.10/24 <span class="comment"># 通过源查询绑定的区域</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> firewall-cmd  --zone=[zone] --change-source=192.168.1.10/24 <span class="comment"># 用于改变source地址所绑定的zone，如果原来没有绑定则进行绑定</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> firewall-cmd --zone=[zone] --remove-source=192.168.1.10/24 <span class="comment"># 解除源的绑定</span></span></span><br></pre></td></tr></tbody></table></figure></div><h5 id="网卡接口-interfaces"><a href="#网卡接口-interfaces" class="headerlink" title="网卡接口(interfaces)"></a>网卡接口(interfaces)</h5><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">shell</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> firewall-cmd --zone=[zone] --add-interface=[interface] <span class="comment"># 添加指定 interface 到指定的 Zone</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> firewall-cmd --zone=[zone] --change-interface=[interface] <span class="comment"># 将eth1接口分配给work区域</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> firewall-cmd --zone=[zone] --remove-interface=[interface] <span class="comment"># 删除work上的eth1接口</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> firewall-cmd --zone=[zone] --list-interfaces <span class="comment"># 查看指定 Zone 下的 interfaces</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> firewall-cmd --get-zone-of-interface=[interface] <span class="comment"># 通过接口查询绑定的区域</span></span></span><br></pre></td></tr></tbody></table></figure></div><h5 id="端口转发-forward-ports"><a href="#端口转发-forward-ports" class="headerlink" title="端口转发(forward-ports)"></a>端口转发(forward-ports)</h5><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">shell</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> firewall-cmd --zone=external --add-forward-port=port=80:proto=tcp:toport=8080 <span class="comment"># 同一主机上的端口转发</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> firewall-cmd --zone=external --add-forward-port=port=80:proto=tcp:toaddr=10.10.10.2 <span class="comment"># 从80端口转发到10.10.10.2的80端口(默认端口)</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> firewall-cmd --zone=external --add-forward-port=port=80:proto=tcp:toport=8080:toaddr=10.10.10.2 <span class="comment"># 从80端口转发到10.10.10.2的8080端口</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> firewall-cmd --zone=external --remove-forward-port=port=80:proto=tcp:toport=8080:toaddr=10.10.10.2 <span class="comment"># 删除上一条的端口转发</span></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">## 伪装 ###</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> firewall-cmd --zone=public --add-masquerade <span class="comment"># 如果需要将流量(端口443)转发到lxd服务器/容器托管，请打开伪装</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> firewall-cmd --zone=public --add-forward-port=port=443:proto=tcp:toport=443:toaddr=192.168.2.42</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> firewall-cmd --zone=public --remove-masquerade <span class="comment"># 删除上面设置的伪装</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> firewall-cmd --zone=public --remove-forward-port=port=443:proto=tcp:toport=443:toaddr=192.168.2.42</span></span><br></pre></td></tr></tbody></table></figure></div><h5 id="服务-services"><a href="#服务-services" class="headerlink" title="服务(services)"></a>服务(services)</h5><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">shell</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> firewall-cmd --zone=public --add-service=http <span class="comment"># 增加服务</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> firewall-cmd --zone=public --list-services <span class="comment"># 列出服务</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> firewall-cmd --zone=public --remove-service=http <span class="comment"># 移除服务</span></span></span><br></pre></td></tr></tbody></table></figure></div><h5 id="协议-protocals"><a href="#协议-protocals" class="headerlink" title="协议(protocals)"></a>协议(protocals)</h5><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">shell</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> firewall-cmd --add-protocol=&lt;protocol&gt; <span class="comment"># 允许协议 (例：icmp，即允许ping)</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> firewall-cmd --remove-protocol=&lt;protocol&gt; <span class="comment"># 取消协议</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> firewall-cmd --list-protocols <span class="comment"># 查看允许的协议</span></span></span><br></pre></td></tr></tbody></table></figure></div><h5 id="高级规则-rich-rules"><a href="#高级规则-rich-rules" class="headerlink" title="高级规则(rich rules)"></a>高级规则(rich rules)</h5><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//区域里的富规则按先后顺序匹配，按先匹配到的规则生效。#firewall-cmd ↓</span><br><span class="line">--add-rich-rule='&lt;RULE&gt;'    //在指定的区添加一条富规则</span><br><span class="line">--remove-rich-rule='&lt;RULE&gt;' //在指定的区删除一条富规则</span><br><span class="line">--query-rich-rule='&lt;RULE&gt;'  //找到规则返回0 ，找不到返回1</span><br><span class="line">--list-rich-rules       //列出指定区里的所有富规则</span><br><span class="line">--list-all 和 --list-all-zones 也能列出存在的富规则</span><br><span class="line"></span><br><span class="line">[rich-rule]有一套完整的 rich-rule-language:</span><br><span class="line">rule</span><br><span class="line">  [family="ipv4|ipv6"]</span><br><span class="line">  [source address="address[/mask]"|mac="mac-address"|ipset="ipset"]</span><br><span class="line">  [destination address="address[/mask]"]</span><br><span class="line">  service|port|protocol|icmp-block|icmp-type|masquerade|forward-port|source-port</span><br><span class="line">  [log]</span><br><span class="line">  [audit]</span><br><span class="line">  [accept|reject|drop|mark]</span><br></pre></td></tr></tbody></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">shell</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> firewall-cmd --add-rich-rule=<span class="string">"rule family="</span>ipv4<span class="string">" source address="</span>192.168.2.1<span class="string">" accept"</span> <span class="comment"># accept表示接受，reject表示拒绝，drop表示直接丢弃，这条命令表示允许来自192.168.2.1的所有流量</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> firewall-cmd --add-rich-rule=<span class="string">"rule family="</span>ipv4<span class="string">" source address="</span>192.168.2.208<span class="string">" service name="</span>ssh<span class="string">" accept"</span> <span class="comment"># 允许192.168.2.208主机访问ssh服务</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> firewall-cmd --add-rich-rule=<span class="string">"rule family="</span>ipv4<span class="string">" source address="</span>192.168.2.1<span class="string">" port protocol="</span>tcp<span class="string">" port="</span>22<span class="string">" accept"</span> <span class="comment"># 允许192.168.2.1主机访问22端口</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> firewall-cmd --zone=drop --add-rich-rule=<span class="string">"rule family="</span>ipv4<span class="string">" source address="</span>192.168.2.0/24<span class="string">" port protocol="</span>tcp<span class="string">" port="</span>22<span class="string">" reject"</span> <span class="comment"># 表示禁止192.168.2.0/24网段的主机访问22端口</span></span></span><br></pre></td></tr></tbody></table></figure></div><h5 id="应急命令"><a href="#应急命令" class="headerlink" title="应急命令"></a>应急命令</h5><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">shell</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> firewall-cmd --panic-on  <span class="comment"># 拒绝所有流量，远程连接会立即断开，只有本地能登陆</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> firewall-cmd --panic-off  <span class="comment"># 取消应急模式，但需要重启firewalld后才可以远程ssh</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> firewall-cmd --query-panic  <span class="comment"># 查看是否为应急模式</span></span></span><br></pre></td></tr></tbody></table></figure></div><h5 id="超时-timeout"><a href="#超时-timeout" class="headerlink" title="超时(timeout)"></a>超时(timeout)</h5><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">shell</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> firewall-cmd --zone=public --add-service=ssh --timeout=5m <span class="comment"># 个timeout 选项是一个以秒（s）、分（m）或小时（h）为单位的时间值,表示该配置有效时间</span></span></span><br></pre></td></tr></tbody></table></figure></div><p>还有许多的规则配置就不一一列举了，需要时去查相关的命令即可。</p><p><strong>注意</strong>，以上配置都是运行时配置，如果需要使其永久生效在命令行后边加上<code>--permanent</code>选项然后重新加载，<strong>或者</strong>使用命令</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">shell</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> firewall-cmd --runtime-to-permanent</span></span><br></pre></td></tr></tbody></table></figure></div><p>也可以自定义自己的zone和service，见后文。</p><h5 id="创建自定义的zone"><a href="#创建自定义的zone" class="headerlink" title="创建自定义的zone"></a>创建自定义的zone</h5><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">shell</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> firewall-cmd --new-zone=memcached --permanent <span class="comment"># 创建zone</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> firewall-cmd --zone=memcached --add-port=11211/udp --permanent <span class="comment"># 添加规则</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> firewall-cmd --zone=memcached --add-source=192.168.100.30/32 --permanent <span class="comment">#同上</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> firewall-cmd --reload <span class="comment"># 重新加载生效</span></span></span><br></pre></td></tr></tbody></table></figure></div><h4 id="服务设置"><a href="#服务设置" class="headerlink" title="服务设置"></a>服务设置</h4><h5 id="获取所有可用服务的列表"><a href="#获取所有可用服务的列表" class="headerlink" title="获取所有可用服务的列表"></a>获取所有可用服务的列表</h5><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">shell</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> firewall-cmd --get-services</span></span><br></pre></td></tr></tbody></table></figure></div><p>通过在<code>/usr/lib/firewalld/services</code>目录中打开相关的.xml文件，您可以找到关于每个服务的更多信息。例如，HTTP服务的定义如下:</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">xml</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">service</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">short</span>&gt;</span>WWW (HTTP)<span class="tag">&lt;/<span class="name">short</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">description</span>&gt;</span>HTTP is the protocol used to serve Web pages. If you plan to make your Web server publicly available, enable this option. This option is not required for viewing pages locally or developing Web pages.<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">port</span> <span class="attr">protocol</span>=<span class="string">"tcp"</span> <span class="attr">port</span>=<span class="string">"80"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">service</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure></div><p>为public区域中的接口允许传入HTTP通信流(端口80)，仅为当前会话(运行时配置)类型：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">shell</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> firewall-cmd --zone=public --add-service=http</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> firewall-cmd --zone=public --list-services <span class="comment"># 查看</span></span></span><br></pre></td></tr></tbody></table></figure></div><p>移除</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">shell</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> firewall-cmd --zone=public --remove-service=http</span></span><br></pre></td></tr></tbody></table></figure></div><h5 id="自定义服务"><a href="#自定义服务" class="headerlink" title="自定义服务"></a>自定义服务</h5><p>如前所述，默认服务存储在<code>/usr/lib/firewalld/services</code>目录中。创建新服务的最简单方法是将现有的服务文件复制到<code>/etc/firewalld/services</code>目录，该目录是用户创建服务的位置，并修改文件设置。我们创建的<code>/etc/firewalld/services/plexmediaserver.xml</code>如下的</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">xml</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">service</span> <span class="attr">version</span>=<span class="string">"1.0"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">short</span>&gt;</span>plexmediaserver<span class="tag">&lt;/<span class="name">short</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">description</span>&gt;</span>Plex is a streaming media server that brings all your video, music and photo collections together and stream them to your devices at anytime and from anywhere.<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">port</span> <span class="attr">protocol</span>=<span class="string">"udp"</span> <span class="attr">port</span>=<span class="string">"1900"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">port</span> <span class="attr">protocol</span>=<span class="string">"tcp"</span> <span class="attr">port</span>=<span class="string">"32400"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">service</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure></div><p>重新加载生效</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">shell</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> firewall-cmd --reload</span></span><br></pre></td></tr></tbody></table></figure></div><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p>其实到这里，我遇到的问题就可以迎刃而解了。</p><h3 id="1-放行整个区域"><a href="#1-放行整个区域" class="headerlink" title="1. 放行整个区域"></a>1. 放行整个区域</h3><p>首先查看网卡接口和区域设置</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">shell</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ip link show</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> firewall-cmd --get-active-zone</span></span><br><span class="line">public</span><br><span class="line">  interfaces: docker0 eth0</span><br></pre></td></tr></tbody></table></figure></div><p>根据<a href="#jump">包处理流程</a>，由于没有源的分配，匹配到 interface 的 Zone，外网访问docker容器服务的时候会匹配到public区域，target是default，于是采用firewall默认行为。所以只要将default设置为ACCEPT便可访问。下面是我的操作,你也可以设置自己的策略。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">shell</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> firewall-cmd --set-default-zone=work <span class="comment"># 设置默认区域为work</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> firewall-cmd --change-interface=docker0 <span class="comment"># 将docker0接口分配到work区域</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> firewall-cmd --permanent --set-target=ACCEPT <span class="comment"># 将target设置为ACCEPT</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> firewall-cmd --runtime-to-permanent <span class="comment"># 设置永久生效</span></span></span><br></pre></td></tr></tbody></table></figure></div><h3 id="2-放行源地址"><a href="#2-放行源地址" class="headerlink" title="2. 放行源地址"></a>2. 放行源地址</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">shell</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> firewall-cmd --zone=home --add-source=192.168.1.1/24 --permanent</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> firewall-cmd --permanent --set-target=ACCEPT --zone=home</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> firewall-cmd --reload</span></span><br></pre></td></tr></tbody></table></figure></div><h3 id="3-docker容器内dns问题"><a href="#3-docker容器内dns问题" class="headerlink" title="3. docker容器内dns问题"></a>3. docker容器内dns问题</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">shell</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> firewall-cmd --zone=public --add-masquerade --permanent &amp;&amp; firewall-cmd --reload</span></span><br></pre></td></tr></tbody></table></figure></div><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://firewalld.org/documentation/concepts.html">https://firewalld.org/documentation/concepts.html</a><br><a href="http://www.solves.com.cn/it/aq/rj/2019-11-21/8339.html">http://www.solves.com.cn/it/aq/rj/2019-11-21/8339.html</a><br><a href="https://www.cnblogs.com/meizy/p/firewall_history_and_firewall_learning.html">https://www.cnblogs.com/meizy/p/firewall_history_and_firewall_learning.html</a><br><a href="https://www.toutiao.com/i6243332343981933058/">https://www.toutiao.com/i6243332343981933058/</a><br><a href="https://zhuanlan.zhihu.com/p/31309295">https://zhuanlan.zhihu.com/p/31309295</a><br><a href="https://linotes.imliloli.com/tools/firewalld/">https://linotes.imliloli.com/tools/firewalld/</a><br><a href="https://linuxize.com/post/how-to-configure-and-manage-firewall-on-centos-8/">https://linuxize.com/post/how-to-configure-and-manage-firewall-on-centos-8/</a><br><a href="https://www.cyberciti.biz/faq/how-to-set-up-a-firewall-using-firewalld-on-centos-8/">https://www.cyberciti.biz/faq/how-to-set-up-a-firewall-using-firewalld-on-centos-8/</a></p></body></html>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用操作</title>
      <link href="/2020/03/03/common-operation/"/>
      <url>/2020/03/03/common-operation/</url>
      
        <content type="html"><![CDATA[<html><head><script src="\assets\js\APlayer.min.js"> </script></head><body><blockquote><p>本文列举了一些常用的操作，供查阅使用</p></blockquote><h1 id="配置yum源"><a href="#配置yum源" class="headerlink" title="配置yum源"></a>配置yum源</h1><h3 id="1-查看linux内核信息"><a href="#1-查看linux内核信息" class="headerlink" title="1. 查看linux内核信息"></a>1. 查看linux内核信息</h3> <div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">shell</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> uname -a<span class="comment"># 查看系统内核信息</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat /proc/version<span class="comment"># 查看内核和GCC信息</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat /etc/redhat-release<span class="comment">#查看发行版本</span></span></span><br></pre></td></tr></tbody></table></figure></div><h3 id="2-配置国内yum源"><a href="#2-配置国内yum源" class="headerlink" title="2. 配置国内yum源"></a>2. 配置国内yum源</h3><ol><li><p>首先进入<code>/etc/yum.repos.d/</code>将原来的yum源备份</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">shell</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> /etc/yum.repos.d/ &amp;&amp; mkdir repo_bak &amp;&amp; mv *.repo repo_bak/</span></span><br></pre></td></tr></tbody></table></figure></div></li><li><p>在CentOS中配置使用yum源</p><p> <a href="https://developer.aliyun.com/mirror/">阿里云官方镜像站</a></p><p><a href="http://mirrors.163.com/.help/">网易开源镜像站</a></p><p><a href="https://lug.ustc.edu.cn/wiki/mirrors/help">中科大开源镜像站</a></p><p><a href="https://mirrors.tuna.tsinghua.edu.cn/">清华大学开源镜像站</a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">shell</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> wget http://mirrors.aliyun.com/repo/Centos-8.repo<span class="comment"># 阿里云yum源</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> wget -O /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-7.repo <span class="comment">#阿里云epel源</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> yum clean all<span class="comment"># 清除yum缓存</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> yum makecache<span class="comment"># 生成新的yum缓存</span></span></span><br></pre></td></tr></tbody></table></figure></div><p>完成。</p></li></ol></body></html>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello Blog!</title>
      <link href="/2020/02/26/hello-blog/"/>
      <url>/2020/02/26/hello-blog/</url>
      
        <content type="html"><![CDATA[<html><head><script src="\assets\js\APlayer.min.js"> </script></head><body><blockquote><p>一封从远方寄来的信</p></blockquote><p>你好，欢迎来到啓東的部落格 ！</p><hr><p>Hello, welcome to my personal blog site!</p><hr><p>こんにちは、ぼくのブログで新たな冒険を始めましょう！</p></body></html>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
